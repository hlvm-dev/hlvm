// Auto-generated file with embedded stdlib modules
// This file is generated by embed-stdlib.ts and should not be edited manually

// Export embedded model from version.ts
export const EMBEDDED_MODEL = "qwen2.5-coder:1.5b";

export const embeddedStdlib = {
  "ai.js": "// src/stdlib/ai.js\n// HLVM Stdlib AI - High-level AI functions\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Constants\nconst SPINNER_INTERVAL = 80;\nconst CONTEXT_WARNING_THRESHOLD = 80;\nconst CONTEXT_CRITICAL_THRESHOLD = 95;\nconst TOKEN_ESTIMATE_DIVISOR = 4;\nconst MAX_CONTEXT_TOKENS = 6000;\nconst MODEL_STARTUP_DELAY = 2000;\nconst DOWNLOAD_WAIT_INTERVAL = 1000;\nconst CONFIRMATION_TIMEOUT = 30000;\nconst PREVIEW_DIVIDER_LENGTH = 50;\n\n// Terminal UI helpers\nconst COLORS = {\n  PURPLE: '\\x1b[35m',\n  BRIGHT_PURPLE: '\\x1b[95m',\n  GREEN: '\\x1b[32m',\n  RED: '\\x1b[91m',\n  YELLOW: '\\x1b[33m',\n  GRAY: '\\x1b[90m',\n  RESET: '\\x1b[0m'\n};\n\nconst TERMINAL = {\n  CLEAR_LINE: '\\x1b[2K',\n  CURSOR_START: '\\x1b[0G',\n  HIDE_CURSOR: '\\x1b[?25l',\n  SHOW_CURSOR: '\\x1b[?25h'\n};\n\nfunction startComputing(message = 'Computing') {\n  const frames = ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'];\n  let i = 0, interval, first = true;\n  try { process.stdout.write(TERMINAL.HIDE_CURSOR); } catch {}\n  const render = () => {\n    const prefix = first ? '\\n' : (TERMINAL.CLEAR_LINE + TERMINAL.CURSOR_START);\n    first = false;\n    try {\n      process.stdout.write(`${prefix}  ${COLORS.PURPLE}${frames[i]}${COLORS.RESET}  ${message}...`);\n    } catch {}\n    i = (i + 1) % frames.length;\n  };\n  render();\n  interval = setInterval(render, SPINNER_INTERVAL);\n  return {\n    update: (m) => { message = m; },\n    stop: () => {\n      clearInterval(interval);\n      try {\n        process.stdout.write(TERMINAL.CLEAR_LINE + TERMINAL.CURSOR_START);\n        process.stdout.write(TERMINAL.SHOW_CURSOR + '\\n');\n      } catch {}\n    }\n  };\n}\n\nfunction showContextUsage(percentage, model = null) {\n  let color = COLORS.PURPLE, icon = '○';\n  if (percentage >= CONTEXT_CRITICAL_THRESHOLD) { color = COLORS.RED; icon = '●'; }\n  else if (percentage >= CONTEXT_WARNING_THRESHOLD) { color = COLORS.YELLOW; icon = '◉'; }\n  const msg = model ? `Approaching ${model} usage limit : ${percentage}% context used`\n                    : `Context usage: ${percentage}%`;\n  try { process.stdout.write(`\\n${color}${icon} ${msg}${COLORS.RESET}\\n`); } catch {}\n}\n\nfunction getDefaultModel() {\n  return globalThis.hlvm?.env?.get?.(\"ai.model\") || globalThis.EMBEDDED_MODEL || \"qwen2.5-coder:1.5b\";\n}\n\nfunction reprintReplPrompt() {\n  try {\n    if (typeof process !== 'undefined' && process.stdout && typeof process.stdout.write === 'function') {\n      process.stdout.write(`\\n${COLORS.GRAY}Done. Press Enter to continue.${COLORS.RESET}\\n`);\n    }\n  } catch {}\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Model manager (Ollama)\nlet modelChecked = false;\nlet modelAvailable = false;\nlet downloadPromise = null; // Use a promise instead of polling\n\nasync function ensureModel(modelName) {\n  const model = modelName || getDefaultModel();\n  if (modelChecked && modelAvailable) return true;\n  \n  // If download is in progress, wait for the existing promise\n  if (downloadPromise) {\n    console.log(\"⏳ Model download already in progress...\");\n    return await downloadPromise;\n  }\n\n  // Create download promise that can be shared\n  downloadPromise = (async () => {\n    try {\n      const ollamaCheck = await globalThis.hlvm.core.ai.ollama.list().catch(() => null);\n      if (!ollamaCheck) {\n        console.log(\"\\n🚀 Starting AI service...\");\n        await globalThis.hlvm.core.system.exec([\"./resources/ollama\", \"serve\"], { background: true });\n        await new Promise(r => setTimeout(r, MODEL_STARTUP_DELAY));\n      }\n\n      const models = await globalThis.hlvm.core.ai.ollama.list();\n      const hasModel = models.models?.some(m => m.name === model);\n      if (hasModel) { \n        modelChecked = true; \n        modelAvailable = true; \n        downloadPromise = null;\n        return true; \n      }\n      console.log(\"\\n╔════════════════════════════════════════════════════════════════╗\");\n      console.log(\"║  🤖 Setting up AI capabilities (one-time download)              ║\");\n      console.log(\"║                                                                  ║\");\n      console.log(`║  Model: ${model.padEnd(54)} ║`);\n      console.log(\"║  This will take a few minutes but only happens once.            ║\");\n      console.log(\"╚════════════════════════════════════════════════════════════════╝\\n\");\n\n      try {\n        // Use streaming to show real-time progress\n        const pullStream = await globalThis.hlvm.core.ai.ollama.pull({ name: model, stream: true });\n        \n        let lastStatus = '';\n        let lastPercent = 0;\n        \n        for await (const progress of pullStream) {\n          if (progress.status) {\n            // Clear previous line and show new status\n            if (lastStatus !== progress.status) {\n              if (lastStatus) process.stdout.write(TERMINAL.CLEAR_LINE + TERMINAL.CURSOR_START);\n              lastStatus = progress.status;\n              \n              // Format status message\n              if (progress.status === 'pulling manifest') {\n                process.stdout.write(`  📋 Pulling manifest...`);\n              } else if (progress.status.includes('pulling')) {\n                const digest = progress.digest ? progress.digest.substring(0, 12) : '';\n                if (progress.completed && progress.total) {\n                  const percent = Math.round((progress.completed / progress.total) * 100);\n                  const mb = Math.round(progress.completed / 1048576);\n                  const totalMb = Math.round(progress.total / 1048576);\n                  \n                  // Create progress bar\n                  const barWidth = 30;\n                  const filled = Math.round((percent / 100) * barWidth);\n                  const bar = '█'.repeat(filled) + '░'.repeat(barWidth - filled);\n                  \n                  process.stdout.write(`  📦 Downloading: [${bar}] ${percent}% (${mb}/${totalMb} MB)`);\n                  lastPercent = percent;\n                } else {\n                  process.stdout.write(`  📦 ${progress.status}${digest ? ` ${digest}` : ''}...`);\n                }\n              } else if (progress.status === 'verifying sha256 digest') {\n                process.stdout.write(`  🔍 Verifying integrity...`);\n              } else if (progress.status === 'writing manifest') {\n                process.stdout.write(`  💾 Finalizing installation...`);\n              } else if (progress.status === 'success') {\n                process.stdout.write(TERMINAL.CLEAR_LINE + TERMINAL.CURSOR_START);\n                console.log(\"  ✅ Model downloaded successfully!\");\n              } else {\n                process.stdout.write(`  ⏳ ${progress.status}...`);\n              }\n            } else if (progress.completed && progress.total) {\n              // Update progress on same line\n              const percent = Math.round((progress.completed / progress.total) * 100);\n              if (percent !== lastPercent) {\n                const mb = Math.round(progress.completed / 1048576);\n                const totalMb = Math.round(progress.total / 1048576);\n                const barWidth = 30;\n                const filled = Math.round((percent / 100) * barWidth);\n                const bar = '█'.repeat(filled) + '░'.repeat(barWidth - filled);\n                \n                process.stdout.write(TERMINAL.CLEAR_LINE + TERMINAL.CURSOR_START);\n                process.stdout.write(`  📦 Downloading: [${bar}] ${percent}% (${mb}/${totalMb} MB)`);\n                lastPercent = percent;\n              }\n            }\n          }\n        }\n        \n        // Ensure we end with a newline\n        console.log(\"\");\n      } catch (e) {\n        console.error(\"\\n❌ Download failed:\", e.message);\n        throw e;\n      }\n\n      const verify = await globalThis.hlvm.core.ai.ollama.list();\n      modelAvailable = verify.models?.some(m => m.name === model);\n      if (modelAvailable) console.log(\"\\n🎉 AI capabilities ready! Your command will now continue...\\n\");\n      else console.error(\"\\n❌ Failed to download model. AI features may not work.\");\n\n      modelChecked = true;\n      downloadPromise = null;\n      return modelAvailable;\n    } catch (err) {\n      downloadPromise = null;\n      modelChecked = true;\n      console.error(\"\\n⚠️ Could not set up AI:\", err.message);\n      console.error(\"   AI features will not be available in this session.\");\n      return false;\n    }\n  })();\n  \n  return await downloadPromise;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Common helpers for deduplication\n\n// Handle Ollama connection errors consistently\nfunction handleOllamaError(error) {\n  console.error(`Failed: ${error.message}`);\n  if (error.message.includes('fetch failed') || error.message.includes('ECONNREFUSED')) {\n    console.error('Ollama service is not running. Start it with: hlvm ollama serve');\n  }\n}\n\n// Clean AI response from markdown/quotes consistently  \nfunction cleanAIResponse(response) {\n  return response\n    .replace(/^```[\\w]*\\n/, '')\n    .replace(/\\n```$/, '')\n    .replace(/^[\"']|[\"']$/g, '')\n    .trim();\n}\n\n// Process streaming response with colored output\nasync function processStream(stream) {\n  let result = '';\n  process.stdout.write(COLORS.GREEN);\n  for await (const chunk of stream) {\n    if (chunk.message?.content) {\n      process.stdout.write(chunk.message.content);\n      result += chunk.message.content;\n    }\n  }\n  process.stdout.write(`${COLORS.RESET}\\n`);\n  reprintReplPrompt();\n  return result;\n}\n\n// Resolve AI options with environment fallbacks\nfunction resolveAIOptions(options = {}, defaults = {}) {\n  return {\n    temperature: options.temperature ?? globalThis.hlvm?.env?.get?.(\"ai.temperature\") ?? defaults.temperature,\n    num_predict: options.num_predict ?? globalThis.hlvm?.env?.get?.(\"ai.max_tokens\") ?? defaults.num_predict,\n    top_p: options.top_p ?? defaults.top_p,\n    repeat_penalty: options.repeat_penalty ?? defaults.repeat_penalty,\n    ...defaults.extra\n  };\n}\n\n// Get input with consistent clipboard fallback\nasync function getInputWithFallback(input) {\n  // If input is explicitly provided (including empty string), use it\n  // Only fallback to clipboard if input is undefined\n  if (input !== undefined) return input;\n  return await globalThis.hlvm.core.io.clipboard.read();\n}\n\n// Handle macOS permission errors consistently\nfunction handleMacOSPermissionError(stderr) {\n  if (!stderr || globalThis.hlvm.core.system.os !== 'darwin') return;\n  \n  const permissionPatterns = [\n    /Operation not permitted/i,\n    /not allowed to send Apple events/i,\n    /Automation.*not allowed/i\n  ];\n  \n  if (permissionPatterns.some(pattern => pattern.test(stderr))) {\n    console.log('\\n🔐 macOS may have blocked this action.');\n    console.log('   Check System Settings → Privacy & Security (Automation / Accessibility / Full Disk Access)');\n    console.log('   Quick open:');\n    console.log('   open \"x-apple.systempreferences:com.apple.preference.security?Privacy\"');\n  }\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// System prompts\nconst SYSTEM_PROMPTS = {\n  default: `Improve this text: fix spelling, grammar, and clarity.\nKeep the original tone and meaning. Return ONLY the revised text.`,\n  professional: `Revise this text to be professional and formal for business communication.\nFix all spelling and grammar errors. Return ONLY the revised text.`,\n  casual: `Make this text casual and conversational while fixing errors.\nKeep it natural and relaxed. Return ONLY the revised text.`,\n  friendly: `Make this text warm, friendly, and approachable.\nFix all errors and add a welcoming tone. Return ONLY the revised text.`,\n  concise: `Make this text concise and to the point while keeping all key information.\nRemove redundancy and fix errors. Return ONLY the revised text.`,\n  formal: `Make this text formal and academic in style.\nUse proper grammar and formal vocabulary. Return ONLY the revised text.`\n};\n\nconst REFACTOR_PROMPTS = {\n  all: `Refactor this code comprehensively:\n- Apply Clean Code principles and improve naming\n- Remove ALL redundancy and duplicate code (DRY)\n- Remove unused variables, functions, imports, and dead code\n- Simplify complex logic and flatten nested structures\n- Update to modern syntax and patterns\n- Optimize performance where obvious\n- Follow SOLID principles where applicable\nReturn ONLY the fully refactored code.`,\n  clean: `Refactor this code following Clean Code principles.\nRemove redundancy, improve naming, extract methods where needed.\nApply DRY principle. Return ONLY the refactored code.`,\n  solid: `Refactor this code following SOLID principles.\nBreak down large parts, improve abstractions. Return ONLY the refactored code.`,\n  dry: `Refactor this code to eliminate ALL redundancy. Return ONLY the refactored code.`,\n  unused: `Remove ALL unused variables/functions/imports/comments. Return ONLY the cleaned code.`,\n  simplify: `Simplify the code for readability without changing behavior. Return ONLY the code.`,\n  modern: `Modernize syntax using latest language features. Return ONLY the code.`,\n  performance: `Optimize for performance while keeping behavior. Return ONLY the code.`\n};\n\nconst DIAGRAM_PROMPTS = {\n  auto: `Analyze this text and create the most appropriate ASCII diagram.\nUse box drawing characters (─│┌┐└┘├┤┬┴┼) and arrows if needed. Return ONLY the diagram.`,\n  flowchart: `Convert this text into an ASCII flowchart with box drawing characters. Return ONLY the flowchart.`,\n  sequence: `Convert this text into an ASCII sequence diagram. Return ONLY the diagram.`,\n  tree: `Convert this text into an ASCII tree. Return ONLY the tree.`,\n  graph: `Convert this text into an ASCII graph/network. Return ONLY the diagram.`,\n  mindmap: `Convert this text into an ASCII mind map. Return ONLY the diagram.`,\n  table: `Extract key data in an ASCII table using box drawing characters. Return ONLY the table.`\n};\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Common request handler - eliminates redundancy across all AI functions\nasync function request(input, config = {}) {\n  // Special case: if skipInputValidation is true, don't process input at all (for chat)\n  const text = config.skipInputValidation ? null : await getInputWithFallback(input);\n  if (!config.skipInputValidation && (!text || !text.trim())) \n    throw new Error(config.error || 'No input provided');\n  \n  const model = config.model || getDefaultModel();\n  await ensureModel(model);\n  \n  const spinner = config.spinner && startComputing(config.spinner);\n  \n  try {\n    const response = await globalThis.hlvm.core.ai.ollama.chat({\n      model,\n      messages: config.messages(text),\n      stream: config.stream ?? false,\n      options: config.options ?? {}\n    });\n    \n    spinner?.stop();\n    return await config.process(response, text);\n  } catch (e) {\n    spinner?.stop();\n    handleOllamaError(e);\n    return config.fallback ?? text;\n  }\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Public helpers: draw / revise / refactor / chat\n\nexport async function draw(input, options = {}) {\n  const type = options.type || 'auto';\n  const style = options.style || 'simple';\n  const validTypes = ['auto','flowchart','sequence','tree','graph','mindmap','table'];\n  if (!validTypes.includes(type)) throw new Error(`Invalid type: ${validTypes.join(', ')}`);\n\n  let systemPrompt = DIAGRAM_PROMPTS[type];\n  systemPrompt += style === 'detailed'\n    ? '\\nInclude more detail and annotations where helpful.'\n    : '\\nKeep it simple and clean, focusing on key elements only.';\n\n  return request(input, {\n    model: options.model,\n    error: 'No text to visualize',\n    spinner: 'Drawing',\n    messages: text => [{ role: 'system', content: systemPrompt }, { role: 'user', content: text }],\n    options: { temperature: 0.1, num_predict: 100, top_p: 0.9, repeat_penalty: 1.0 },\n    process: async response => {\n      let diagram = cleanAIResponse(response.message?.content || '');\n      const ok = /[─│┌┐└┘├┤┬┴┼▼▲►◄╭╮╰╯═║╔╗╚╝╠╣╦╩╬]/.test(diagram);\n      if (!ok && diagram.length < 50) console.warn('Generated output may not be a valid diagram');\n      return diagram;\n    },\n    fallback: '[Cannot generate diagram]'\n  });\n}\n\nexport async function revise(input, options = {}) {\n  const tone = options.tone || 'default';\n  const valid = ['default','professional','casual','friendly','concise','formal'];\n  if (!valid.includes(tone)) throw new Error(`Invalid tone: ${valid.join(', ')}`);\n  const systemPrompt = SYSTEM_PROMPTS[tone];\n\n  return request(input, {\n    model: options.model,\n    error: 'No text to revise',\n    spinner: 'Revising',\n    messages: text => [{ role: 'system', content: systemPrompt }, { role: 'user', content: text }],\n    stream: true,\n    options: resolveAIOptions(options, {\n      temperature: 0.3,\n      num_predict: 2000,\n      top_p: 0.9,\n      repeat_penalty: 1.1\n    }),\n    process: async (stream, original) => {\n      let revised = await processStream(stream);\n      revised = cleanAIResponse(revised);\n      if (!revised) { console.warn('Revision empty; returning original'); return original; }\n      const ratio = revised.length / original.length;\n      if (ratio < 0.2 || ratio > 5) { console.warn('Revision length off; returning original'); return original; }\n      return revised;\n    }\n  });\n}\n\nexport async function refactor(input, options = {}) {\n  const type = options.type || 'all';\n  const valid = ['all','clean','solid','dry','unused','simplify','modern','performance'];\n  if (!valid.includes(type)) throw new Error(`Invalid type: ${valid.join(', ')}`);\n  const systemPrompt = REFACTOR_PROMPTS[type];\n\n  return request(input, {\n    model: options.model,\n    error: 'No code to refactor',\n    spinner: 'Refactoring',\n    messages: code => [{ role: 'system', content: systemPrompt }, { role: 'user', content: code }],\n    options: resolveAIOptions(options, {\n      temperature: 0.2,\n      num_predict: 4000,\n      top_p: 0.95,\n      repeat_penalty: 1.0\n    }),\n    process: async (response, original) => {\n      let out = cleanAIResponse(response.message?.content || original);\n      if (!out) { console.warn('Refactoring empty; returning original'); return original; }\n      return out;\n    }\n  });\n}\n\nconst chatHistory = [];\nconst estimateTokens = (t) => Math.ceil((t || '').length / TOKEN_ESTIMATE_DIVISOR);\nconst calculateHistoryTokens = (msgs) => msgs.reduce((acc, m) => acc + estimateTokens(m.content || ''), 0);\nfunction trimHistory(messages, maxTokens = MAX_CONTEXT_TOKENS) {\n  if (!messages.length) return messages;\n  const minKeep = Math.min(2, messages.length);\n  const out = [];\n  let count = 0;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const t = estimateTokens(messages[i].content || '');\n    if (out.length < minKeep || count + t <= maxTokens) { out.unshift(messages[i]); count += t; }\n    else break;\n  }\n  return out;\n}\n\nexport async function chat(input, options = {}) {\n  // Special handling for chat history\n  const question = await getInputWithFallback(input);\n  if (!question?.trim()) throw new Error('No question to ask');\n  \n  const model = options.model || globalThis.hlvm?.env?.get?.(\"ai.model\") || getDefaultModel();\n  \n  let messages;\n  if (options.stateless) {\n    messages = [{ role: 'user', content: question }];\n  } else {\n    if (chatHistory.length === 0 || chatHistory[0].role !== 'system') {\n      chatHistory.unshift({\n        role: 'system',\n        content: 'You are a helpful assistant. Remember and use all information from our conversation. When asked about previous topics, refer back to what was discussed earlier.'\n      });\n    }\n    chatHistory.push({ role: 'user', content: question });\n    const currentTokens = calculateHistoryTokens(chatHistory);\n    if (currentTokens > MAX_CONTEXT_TOKENS) {\n      const trimmed = trimHistory(chatHistory, MAX_CONTEXT_TOKENS);\n      chatHistory.length = 0; chatHistory.push(...trimmed);\n    }\n    const usage = Math.round((calculateHistoryTokens(chatHistory) / 8192) * 100);\n    if (usage > 80) showContextUsage(usage, model);\n    messages = chatHistory;\n  }\n\n  if (options.debug) {\n    console.log(`${COLORS.GRAY}[DEBUG] Sending messages:${COLORS.RESET}`);\n    messages.forEach((m,i) => console.log(`${COLORS.GRAY}  [${i}] ${m.role}: ${(m.content||'').slice(0,50)}...${COLORS.RESET}`));\n    console.log(`${COLORS.GRAY}[DEBUG] Total tokens: ~${calculateHistoryTokens(messages)}${COLORS.RESET}`);\n  }\n\n  // Use request but with pre-built messages\n  return request(null, {\n    model,\n    skipInputValidation: true,  // Chat handles its own input validation\n    spinner: options.stream !== false ? 'Generating' : null,\n    messages: () => messages,  // Already built above\n    stream: options.stream !== false,\n    options: resolveAIOptions(options, {\n      temperature: 0.7,\n      num_predict: 2000,\n      top_p: 0.95,\n      repeat_penalty: 1.1,\n      extra: { num_ctx: 8192 }\n    }),\n    process: async (response) => {\n      if (options.stream !== false) {\n        let answer = await processStream(response);\n        if (!options.stateless) chatHistory.push({ role: 'assistant', content: answer.trim() });\n        return answer.trim();\n      } else {\n        const answer = response.message?.content || '';\n        if (!options.stateless) chatHistory.push({ role: 'assistant', content: answer });\n        return answer;\n      }\n    },\n    fallback: `[Error]`\n  });\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// ASK: natural language → command + confirm + exec\n// NEW: /dev/tty single-keypress Y/N, real ESC, confirm:false skip, verbose logs\n\n\n\n\n\nexport async function judge(statement, options = {}) {\n  const systemPrompt = `You are a binary truth evaluator. Analyze the given statement and respond with ONLY \"true\" or \"false\".\nRules:\n- If factually accurate or logically sound: true\n- If false, incorrect, or logically flawed: false  \n- If uncertain or unprovable: false\n- No explanations, just true/false`;\n\n  return request(statement, {\n    model: options.model,\n    error: 'No statement to judge',\n    messages: text => [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: text }\n    ],\n    options: { temperature: 0.1, num_predict: 5, top_p: 0.9 },\n    process: async response => {\n      const answer = (response.message?.content || '').toLowerCase().trim();\n      return answer === 'true' || answer.includes('true');\n    },\n    fallback: false\n  });\n}\n\nexport async function ask(command, options = {}) {\n  const { confirm = true } = options;\n  if (!command || command.trim() === '') throw new Error('No command provided');\n\n  const platform = globalThis.hlvm.core.system.os;\n  const prompt = `Generate a minimal executable shell command for: \"${command}\"\nPlatform: ${platform}\n\nCRITICAL RULES:\n1. Output ONLY the raw command - no backticks, no quotes around the whole command\n2. Use simple shell commands only\n3. For macOS: use 'open' for apps/URLs\n4. Ensure all quotes are properly closed\n5. DO NOT wrap the command in backticks like \\`command\\`\n6. DO NOT add markdown formatting\n\nCORRECT Examples:\n\"open facebook\" → open https://facebook.com\n\"show tesla stock\" → open https://finance.yahoo.com/quote/TSLA\n\"list files\" → ls -la\n\"echo hello\" → echo \"hello\"\n\"open safari\" → open -a Safari\n\nWRONG Examples:\n\\`echo \"hello\"\\`\necho 'hello\n\"ls -la\"\nOutput the raw shell command only:`;\n\n  try {\n    const computing = startComputing('Generating');\n    const model = getDefaultModel();\n    await ensureModel(model);\n\n    // Simple generation without ESC watcher (it conflicts with REPL)\n    const response = await globalThis.hlvm.core.ai.ollama.chat({\n      model,\n      messages: [{ role: 'system', content: prompt }, { role: 'user', content: command }],\n      stream: false,\n      options: { temperature: 0.3, num_predict: 100, top_p: 0.9 }\n    });\n\n    computing.stop();\n    let script = response.message?.content || '';\n    \n    // Clean up AI output\n    script = cleanAIResponse(script);\n    if (script.startsWith('`') && script.endsWith('`')) script = script.slice(1, -1);\n\n    // Fix unbalanced quotes\n    const count = (str, re) => (str.match(re) || []).length;\n    const dq = count(script, /(?<!\\\\)\"/g);\n    const sq = count(script, /(?<!\\\\)'/g);\n    if (dq % 2 === 1) script += '\"';\n    if (sq % 2 === 1) script += \"'\";\n\n    if (!script) { console.error('❌ Failed to generate command'); return null; }\n\n    // Preview\n    console.log('\\n📋 Will execute:');\n    console.log('─'.repeat(PREVIEW_DIVIDER_LENGTH));\n    console.log(COLORS.GREEN + script + COLORS.RESET);\n    console.log('─'.repeat(PREVIEW_DIVIDER_LENGTH));\n\n    // Confirmation or skip\n    if (confirm === false) {\n    } else {\n      // Clean UI with emoji and clear instructions\n      console.log(\"\\n  ❓ Execute this command?\");\n      console.log(\"\");\n      console.log(`     ${COLORS.GREEN}→ y${COLORS.RESET}  = Yes, execute`);\n      console.log(`     ${COLORS.RED}→ n${COLORS.RESET}  = No, cancel`);\n      console.log(\"\");\n      process.stdout.write(\"> \"); // Show prompt to indicate waiting for input\n      \n      // Set up Promise-based response handling\n      let response = await new Promise((resolve) => {\n        const timeoutId = setTimeout(() => {\n          delete globalThis.y;\n          delete globalThis.n;\n          resolve(null); // Timeout\n        }, CONFIRMATION_TIMEOUT);\n        \n        Object.defineProperty(globalThis, 'y', {\n          get: function() {\n            clearTimeout(timeoutId);\n            delete globalThis.y;\n            delete globalThis.n;\n            console.log(\"✅ Proceeding with execution...\");\n            resolve('yes');\n            return undefined;\n          },\n          configurable: true\n        });\n        \n        Object.defineProperty(globalThis, 'n', {\n          get: function() {\n            clearTimeout(timeoutId);\n            delete globalThis.y;\n            delete globalThis.n;\n            console.log(\"❌ Cancelled\");\n            resolve('no');\n            return undefined;\n          },\n          configurable: true\n        });\n      });\n      \n      if (!response || response !== 'yes') {\n        if (!response) console.log(\"⏱️  Timeout - cancelled\");\n        process.stdout.write(\"\\n> \"); // Show prompt after cancel\n        return null;\n      }\n    }\n\n    // Execute\n    console.log('\\n⚡ Executing...');\n    try {\n      if (globalThis.hlvm.core.system.os === 'darwin' && script.startsWith('open ')) {\n        script = script.replace(/^open\\s/, '/usr/bin/open ');\n      }\n\n      // Always pass as a SINGLE STRING\n      let result = await globalThis.hlvm.core.system.exec(script);\n\n      if (result && (result.code === 127 || (result.stderr && result.stderr.includes('not found')))) {\n        console.log('Trying with shell...');\n        const escaped = script.replace(/'/g, \"'\\\\''\");\n        result = await globalThis.hlvm.core.system.exec(`/bin/sh -c '${escaped}'`);\n      }\n\n      if (result && result.stdout) console.log(result.stdout);\n\n      if (result && result.code === 0) {\n        console.log('✅ Done\\n');\n        process.stdout.write(\"> \"); // Show prompt to indicate ready for next command\n      } else if (result) {\n        console.log(`❌ Command failed with code ${result.code}`);\n        if (result.stderr) console.error(result.stderr);\n\n        // Permission hints on macOS\n        handleMacOSPermissionError(result.stderr);\n      }\n      if (result?.code !== 0) {\n        process.stdout.write(\"\\n> \"); // Show prompt after error\n      }\n      return result;\n    } catch (execError) {\n      console.error('❌ Execution error:', execError.message);\n      process.stdout.write(\"\\n> \"); // Show prompt after error\n      return null;\n    }\n  } catch (error) {\n    console.error('❌ Error:', error.message);\n    handleOllamaError(error);\n    process.stdout.write(\"\\n> \"); // Show prompt after error\n    return null;\n  }\n}\n\n// Add documentation to functions (but NOT customInspect to avoid messing up structure display)\nrevise.__doc__ = `revise(text, options?)\nRevises and improves text quality\nOptions: tone (default/professional/casual/friendly/concise/formal), model`;\n\ndraw.__doc__ = `draw(text, options?)\nCreates ASCII diagrams from text\nOptions: type (auto/flowchart/sequence/tree/graph/mindmap/table), style (simple/detailed), model`;\n\nchat.__doc__ = `chat(messages, options?)\nInteractive chat with AI\nOptions: model, stream, temperature, num_predict, top_p`;\n\nrefactor.__doc__ = `refactor(code, options?)\nRefactors code following best practices\nOptions: type (all/clean/solid/dry/unused/simplify/modern/performance), model`;\n\nask.__doc__ = `ask(command, options?)\nGenerates and optionally executes shell commands from natural language\nOptions: confirm (true/false), model`;\n\njudge.__doc__ = `judge(statement, options?)\nEvaluates truth value of a statement (returns true/false)\nOptions: model`;\n\nexport default { revise, draw, chat, refactor, ask, judge };\n",
  "ai/ollama.js": "// Ollama module - Complete mirror of Ollama API\n// https://github.com/ollama/ollama/blob/main/docs/api.md\n\nconst OLLAMA_HOST = Deno.env.get(\"OLLAMA_HOST\") || \"http://localhost:11434\";\n\n// Helper for streaming responses\nasync function* streamResponse(response) {\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  \n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    \n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() || \"\";\n    \n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          yield JSON.parse(line);\n        } catch (e) {\n          console.error(\"Failed to parse:\", line);\n        }\n      }\n    }\n  }\n}\n\n// Generic API request handler - DRY principle\nasync function apiRequest(endpoint, method = \"GET\", body = null) {\n  const options = {\n    method,\n    headers: method !== \"GET\" ? { \"Content-Type\": \"application/json\" } : {}\n  };\n  \n  if (body && method !== \"GET\") {\n    options.body = JSON.stringify(body);\n  }\n  \n  const response = await fetch(`${OLLAMA_HOST}/api/${endpoint}`, options);\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    let message = `Ollama ${endpoint} failed: ${response.statusText}`;\n    try {\n      const parsed = JSON.parse(errorText);\n      if (parsed.error) message = parsed.error;\n    } catch {}\n    throw new Error(message);\n  }\n  \n  return response;\n}\n\n// Handle streaming or JSON response - DRY principle\nasync function handleResponse(response, request) {\n  if (request?.stream === false) {\n    return await response.json();\n  }\n  return response.headers.get(\"content-type\")?.includes(\"application/json\")\n    ? await response.json()\n    : streamResponse(response);\n}\n\n/**\n * Generate a completion from a model\n * @param {Object} request - Generation request\n * @param {string} request.model - Model name (e.g., \"llama3\", \"mistral\")\n * @param {string} request.prompt - Prompt to generate from\n * @param {boolean} [request.stream=true] - Stream response chunks\n * @param {Object} [request.options] - Model options (temperature, num_predict, etc.)\n * @returns {Promise<Object|AsyncGenerator>} Response or stream of responses\n * @example\n * await generate({model: \"llama3\", prompt: \"Why is the sky blue?\"})\n * // → {response: \"The sky appears blue because...\", done: true}\n * @example\n * for await (const chunk of await generate({model: \"llama3\", prompt: \"Hello\", stream: true})) {\n *   process.stdout.write(chunk.response)\n * }\n * // → Streams response word by word\n */\nexport async function generate(request) {\n  const response = await apiRequest(\"generate\", \"POST\", request);\n  return handleResponse(response, request);\n}\n\n/**\n * Chat with a model (conversation with context)\n * @param {Object} request - Chat request\n * @param {string} request.model - Model name\n * @param {Array} request.messages - Message history [{role, content}]\n * @param {boolean} [request.stream=true] - Stream response\n * @param {Object} [request.options] - Model options\n * @returns {Promise<Object|AsyncGenerator>} Response or stream\n * @example\n * await chat({\n *   model: \"llama3\",\n *   messages: [\n *     {role: \"user\", content: \"What is 2+2?\"},\n *     {role: \"assistant\", content: \"4\"},\n *     {role: \"user\", content: \"What about 3+3?\"}\n *   ]\n * })\n * // → {message: {role: \"assistant\", content: \"3+3 equals 6\"}}\n */\nexport async function chat(request) {\n  const response = await apiRequest(\"chat\", \"POST\", request);\n  return handleResponse(response, request);\n}\n\n/**\n * Create a custom model from a Modelfile\n * @param {Object} request - Create request\n * @param {string} request.name - Model name to create\n * @param {string} request.modelfile - Modelfile content\n * @param {boolean} [request.stream=true] - Stream progress\n * @returns {Promise<Object|AsyncGenerator>} Creation status\n * @example\n * await create({\n *   name: \"mario\",\n *   modelfile: \"FROM llama3\\nSYSTEM You are Mario from Nintendo.\"\n * })\n * // → {status: \"success\"}\n */\nexport async function create(request) {\n  const response = await apiRequest(\"create\", \"POST\", request);\n  return handleResponse(response, request);\n}\n\n/**\n * List available models\n * @returns {Promise<Object>} List of models\n * @example\n * await list()\n * // → {models: [{name: \"llama3:latest\", size: 4661224676, digest: \"abc123...\"}]}\n */\nexport async function list() {\n  const response = await apiRequest(\"tags\");\n  return response.json();\n}\n\n/**\n * Show model information and Modelfile\n * @param {Object} request - Show request\n * @param {string} request.name - Model name\n * @returns {Promise<Object>} Model details\n * @example\n * await show({name: \"llama3\"})\n * // → {modelfile: \"FROM llama3...\", parameters: \"...\", template: \"...\"}\n */\nexport async function show(request) {\n  const response = await apiRequest(\"show\", \"POST\", request);\n  return response.json();\n}\n\n/**\n * Copy a model to a new name\n * @param {Object} request - Copy request\n * @param {string} request.source - Source model name\n * @param {string} request.destination - New model name\n * @returns {Promise<boolean>} Success status\n * @example\n * await copy({source: \"llama3\", destination: \"my-llama\"})\n * // → true\n */\nexport async function copy(request) {\n  await apiRequest(\"copy\", \"POST\", request);\n  return true;\n}\n\n/**\n * Delete a model\n * @param {Object} request - Delete request\n * @param {string} request.name - Model name to delete\n * @returns {Promise<boolean>} Success status\n * @example\n * await deleteModel({name: \"my-custom-model\"})\n * // → true\n */\nexport async function deleteModel(request) {\n  await apiRequest(\"delete\", \"DELETE\", request);\n  return true;\n}\n\n/**\n * Pull/download a model from the registry\n * @param {Object} request - Pull request\n * @param {string} request.name - Model name to pull\n * @param {boolean} [request.stream=true] - Stream download progress\n * @returns {Promise<Object|AsyncGenerator>} Download progress or status\n * @example\n * await pull({name: \"llama3\", stream: false})\n * // → {status: \"success\"}\n * @example\n * for await (const progress of await pull({name: \"mistral\"})) {\n *   console.log(`Downloaded: ${progress.completed}/${progress.total}`)\n * }\n * // → Shows download progress\n */\nexport async function pull(request) {\n  const response = await apiRequest(\"pull\", \"POST\", request);\n  return handleResponse(response, request);\n}\n\n/**\n * Push a model to the registry\n * @param {Object} request - Push request\n * @param {string} request.name - Model name to push\n * @param {boolean} [request.stream=true] - Stream upload progress\n * @returns {Promise<Object|AsyncGenerator>} Upload progress or status\n * @example\n * await push({name: \"myorg/mymodel\", stream: false})\n * // → {status: \"success\"}\n */\nexport async function push(request) {\n  const response = await apiRequest(\"push\", \"POST\", request);\n  return handleResponse(response, request);\n}\n\n/**\n * Generate embeddings from text\n * @param {Object} request - Embeddings request\n * @param {string} request.model - Model name\n * @param {string} request.prompt - Text to embed\n * @returns {Promise<Object>} Embedding vector\n * @example\n * await embeddings({model: \"llama3\", prompt: \"Hello world\"})\n * // → {embedding: [0.1, -0.2, 0.3, ...]}\n */\nexport async function embeddings(request) {\n  const response = await apiRequest(\"embeddings\", \"POST\", request);\n  return response.json();\n}\n\n/**\n * List running models\n * @returns {Promise<Object>} Running models info\n * @example\n * await ps()\n * // → {models: [{name: \"llama3\", size: 4661224676, digest: \"abc...\", expires_at: \"...\"}]}\n */\nexport async function ps() {\n  const response = await apiRequest(\"ps\");\n  return response.json();\n}\n\n/**\n * Check if Ollama service is running\n * @returns {Promise<boolean>} True if running\n * @example\n * await isRunning()\n * // → true\n */\nexport async function isRunning() {\n  try {\n    const response = await fetch(`${OLLAMA_HOST}/api/tags`);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n\n// Initialize on module load\n",
  "app/control.js": "// HLVM App Control - Cross-platform application control\n// Provides unified API for controlling applications across macOS, Windows, and Linux\n\n/**\n * Known application mappings for common apps across platforms\n * Maps simple names to platform-specific identifiers\n */\nconst APP_REGISTRY = {\n  // Browsers\n  'safari': {\n    darwin: 'Safari',\n    windows: null, // Not available on Windows\n    linux: null\n  },\n  'chrome': {\n    darwin: 'Google Chrome',\n    windows: 'chrome.exe',\n    linux: 'google-chrome'\n  },\n  'firefox': {\n    darwin: 'Firefox',\n    windows: 'firefox.exe',\n    linux: 'firefox'\n  },\n  'edge': {\n    darwin: 'Microsoft Edge',\n    windows: 'msedge.exe',\n    linux: 'microsoft-edge'\n  },\n  'arc': {\n    darwin: 'Arc',\n    windows: null,\n    linux: null\n  },\n  \n  // IDEs and Editors\n  'vscode': {\n    darwin: 'Visual Studio Code',\n    windows: 'Code.exe',\n    linux: 'code'\n  },\n  'xcode': {\n    darwin: 'Xcode',\n    windows: null,\n    linux: null\n  },\n  'sublime': {\n    darwin: 'Sublime Text',\n    windows: 'sublime_text.exe',\n    linux: 'sublime_text'\n  },\n  'atom': {\n    darwin: 'Atom',\n    windows: 'atom.exe',\n    linux: 'atom'\n  },\n  'intellij': {\n    darwin: 'IntelliJ IDEA',\n    windows: 'idea64.exe',\n    linux: 'idea'\n  },\n  'cursor': {\n    darwin: 'Cursor',\n    windows: 'Cursor.exe',\n    linux: 'cursor'\n  },\n  \n  // Terminals\n  'terminal': {\n    darwin: 'Terminal',\n    windows: 'cmd.exe',\n    linux: 'gnome-terminal'\n  },\n  'iterm': {\n    darwin: 'iTerm',\n    windows: null,\n    linux: null\n  },\n  'warp': {\n    darwin: 'Warp',\n    windows: null,\n    linux: null\n  },\n  'powershell': {\n    darwin: null,\n    windows: 'powershell.exe',\n    linux: 'pwsh'\n  },\n  \n  // Communication\n  'slack': {\n    darwin: 'Slack',\n    windows: 'slack.exe',\n    linux: 'slack'\n  },\n  'discord': {\n    darwin: 'Discord',\n    windows: 'Discord.exe',\n    linux: 'discord'\n  },\n  'zoom': {\n    darwin: 'zoom.us',\n    windows: 'Zoom.exe',\n    linux: 'zoom'\n  },\n  'teams': {\n    darwin: 'Microsoft Teams',\n    windows: 'Teams.exe',\n    linux: 'teams'\n  },\n  'messages': {\n    darwin: 'Messages',\n    windows: null,\n    linux: null\n  },\n  \n  // Productivity\n  'notion': {\n    darwin: 'Notion',\n    windows: 'Notion.exe',\n    linux: 'notion'\n  },\n  'obsidian': {\n    darwin: 'Obsidian',\n    windows: 'Obsidian.exe',\n    linux: 'obsidian'\n  },\n  'notes': {\n    darwin: 'Notes',\n    windows: 'onenote.exe',\n    linux: null\n  },\n  \n  // System Apps\n  'finder': {\n    darwin: 'Finder',\n    windows: 'explorer.exe',\n    linux: 'nautilus'\n  },\n  'explorer': {\n    darwin: 'Finder',\n    windows: 'explorer.exe',\n    linux: 'nautilus'\n  },\n  'settings': {\n    darwin: 'System Settings',\n    windows: 'SystemSettings.exe',\n    linux: 'gnome-control-center'\n  },\n  'preferences': {\n    darwin: 'System Settings',\n    windows: 'SystemSettings.exe',\n    linux: 'gnome-control-center'\n  },\n  \n  // Media\n  'music': {\n    darwin: 'Music',\n    windows: 'iTunes.exe',\n    linux: 'rhythmbox'\n  },\n  'spotify': {\n    darwin: 'Spotify',\n    windows: 'Spotify.exe',\n    linux: 'spotify'\n  },\n  'vlc': {\n    darwin: 'VLC',\n    windows: 'vlc.exe',\n    linux: 'vlc'\n  }\n};\n\n/**\n * Platform abstraction layer\n * Provides unified interface for platform-specific operations\n */\nclass PlatformAdapter {\n  constructor() {\n    // Lazy initialization to avoid circular dependency\n    this._initialized = false;\n  }\n  \n  _init() {\n    if (this._initialized) return;\n    this.platform = globalThis.hlvm.core.system.os;\n    this.isDarwin = globalThis.hlvm.core.system.isDarwin;\n    this.isWindows = globalThis.hlvm.core.system.isWindows;\n    this.isLinux = globalThis.hlvm.core.system.isLinux;\n    this._initialized = true;\n  }\n\n  /**\n   * Resolve app identifier for current platform\n   */\n  resolveAppName(identifier) {\n    this._init(); // Ensure initialized\n    // Check if it's a known app alias\n    const lowerName = identifier.toLowerCase();\n    if (APP_REGISTRY[lowerName]) {\n      const mapped = APP_REGISTRY[lowerName][this.platform];\n      if (mapped) return mapped;\n    }\n    \n    // Return as-is if not found in registry\n    return identifier;\n  }\n\n  /**\n   * Execute platform-specific command\n   */\n  async executeCommand(command) {\n    const result = await globalThis.hlvm.core.system.exec(command);\n    return result;\n  }\n\n  /**\n   * List running applications\n   */\n  async listApps() {\n    this._init(); // Ensure initialized\n    if (this.isDarwin) {\n      const script = `tell application \"System Events\" to get name of every process whose background only is false`;\n      const result = await this.runAppleScript(script);\n      const trimmed = result.trim();\n      if (!trimmed) return [];\n      return trimmed.split(', ').filter(name => name.length > 0);\n    } \n    else if (this.isWindows) {\n      const command = `powershell -Command \"Get-Process | Where-Object {$_.MainWindowTitle -ne ''} | Select-Object -ExpandProperty ProcessName | Select-Object -Unique\"`;\n      const result = await this.executeCommand(command);\n      return result.stdout.split('\\n').filter(name => name.trim().length > 0);\n    }\n    else if (this.isLinux) {\n      const command = `wmctrl -l | awk '{for(i=4;i<=NF;i++) printf \"%s \", $i; print \"\"}' | sort -u`;\n      const result = await this.executeCommand(command);\n      return result.stdout.split('\\n').filter(name => name.trim().length > 0);\n    }\n    return [];\n  }\n\n  /**\n   * Get frontmost application\n   */\n  async getFrontmost() {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"System Events\" to get name of first process whose frontmost is true`;\n      const name = await this.runAppleScript(script);\n      return name.trim();\n    }\n    else if (this.isWindows) {\n      const command = `powershell -Command \"Add-Type @' \nusing System;\nusing System.Runtime.InteropServices;\npublic class Win32 {\n  [DllImport(\"user32.dll\")]\n  public static extern IntPtr GetForegroundWindow();\n  [DllImport(\"user32.dll\")]\n  public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);\n}\n'@; $hwnd = [Win32]::GetForegroundWindow(); $pid = 0; [Win32]::GetWindowThreadProcessId($hwnd, [ref]$pid); (Get-Process -Id $pid).ProcessName\"`;\n      const result = await this.executeCommand(command);\n      return result.stdout.trim();\n    }\n    else if (this.isLinux) {\n      const command = `xdotool getactivewindow getwindowname`;\n      const result = await this.executeCommand(command);\n      return result.stdout.trim();\n    }\n    return null;\n  }\n\n  /**\n   * Launch application and wait for it to be ready\n   * @param {string} appName - Application name\n   * @param {string} [url] - Optional URL to open (for browsers)\n   */\n  async launchApp(appName, url = null) {\n    this._init();\n    \n    // Check if already running\n    const wasRunning = await this.isAppRunning(appName);\n    \n    if (this.isDarwin) {\n      if (url) {\n        // For browsers with URLs, use AppleScript to ensure URL opens\n        // This works whether the app is running or not\n        const script = `\n          tell application \"${appName}\"\n            activate\n            open location \"${url}\"\n          end tell\n        `;\n        await this.runAppleScript(script);\n      } else {\n        const script = `tell application \"${appName}\" to launch`;\n        await this.runAppleScript(script);\n      }\n    }\n    else if (this.isWindows) {\n      if (url) {\n        await this.executeCommand(`start \"\" \"${appName}\" \"${url}\"`);\n      } else {\n        await this.executeCommand(`start \"\" \"${appName}\"`);\n      }\n    }\n    else if (this.isLinux) {\n      if (url) {\n        await this.executeCommand(`${appName} \"${url}\" &`);\n      } else {\n        await this.executeCommand(`${appName} &`);\n      }\n    }\n    \n    // If app wasn't running, wait for it to be ready\n    if (!wasRunning) {\n      await this.waitForApp(appName);\n    }\n    \n    return !wasRunning; // Return true if we launched it\n  }\n  \n  /**\n   * Wait for application to be ready (windows loaded, responsive)\n   */\n  async waitForApp(appName, maxWait = 10000) {\n    this._init();\n    const startTime = Date.now();\n    \n    // First wait for process to exist\n    while (Date.now() - startTime < maxWait) {\n      if (await this.isAppRunning(appName)) {\n        break;\n      }\n      await new Promise(r => setTimeout(r, 100));\n    }\n    \n    // Then wait for window to be ready (check if it has windows)\n    if (this.isDarwin) {\n      // Wait for app to have at least one window\n      const waitScript = `\n        tell application \"${appName}\"\n          repeat 50 times\n            try\n              if (count windows) > 0 then\n                return true\n              end if\n            end try\n            delay 0.1\n          end repeat\n          return false\n        end tell\n      `;\n      await this.runAppleScript(waitScript);\n    }\n    \n    // Additional small delay for UI to be fully ready\n    await new Promise(r => setTimeout(r, 200));\n  }\n\n  /**\n   * Activate (bring to front) application\n   */\n  async activateApp(appName) {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"${appName}\" to activate`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      // Use PowerShell to activate window\n      const command = `powershell -Command \"(New-Object -ComObject Shell.Application).Windows() | Where-Object {$_.Name -like '*${appName}*'} | ForEach-Object {$_.Visible = $true}\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      await this.executeCommand(`wmctrl -a \"${appName}\"`);\n    }\n  }\n\n  /**\n   * Quit application\n   */\n  async quitApp(appName) {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"${appName}\" to quit`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      await this.executeCommand(`taskkill /IM \"${appName}\" /F`);\n    }\n    else if (this.isLinux) {\n      await this.executeCommand(`pkill -f \"${appName}\"`);\n    }\n  }\n\n  /**\n   * Check if application is running\n   */\n  async isAppRunning(appName) {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"System Events\" to (name of processes) contains \"${appName}\"`;\n      const result = await this.runAppleScript(script);\n      return result.trim() === 'true';\n    }\n    else if (this.isWindows) {\n      const command = `tasklist /FI \"IMAGENAME eq ${appName}\" 2>NUL | find /I /N \"${appName}\"`;\n      const result = await this.executeCommand(command);\n      return result.code === 0;\n    }\n    else if (this.isLinux) {\n      const command = `pgrep -f \"${appName}\"`;\n      const result = await this.executeCommand(command);\n      return result.code === 0;\n    }\n    return false;\n  }\n\n  /**\n   * Hide application\n   */\n  async hideApp(appName) {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"System Events\" to set visible of process \"${appName}\" to false`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      // Minimize window on Windows\n      const command = `powershell -Command \"(New-Object -ComObject Shell.Application).Windows() | Where-Object {$_.Name -like '*${appName}*'} | ForEach-Object {$_.Minimize()}\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      await this.executeCommand(`xdotool search --name \"${appName}\" windowminimize`);\n    }\n  }\n\n  /**\n   * Show application\n   */\n  async showApp(appName) {\n    this._init();\n    if (this.isDarwin) {\n      const script = `tell application \"System Events\" to set visible of process \"${appName}\" to true`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      // Restore window on Windows\n      const command = `powershell -Command \"(New-Object -ComObject Shell.Application).Windows() | Where-Object {$_.Name -like '*${appName}*'} | ForEach-Object {$_.Restore()}\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      await this.executeCommand(`xdotool search --name \"${appName}\" windowactivate`);\n    }\n  }\n\n  /**\n   * Maximize application window\n   */\n  async maximizeApp(appName) {\n    this._init();\n    \n    if (this.isDarwin) {\n      // Use AppleScript to click the green maximize button\n      const script = `\n        tell application \"System Events\"\n          tell process \"${appName}\"\n            try\n              click button 2 of window 1\n            on error\n              -- Fallback to fullscreen shortcut\n              keystroke \"f\" using {command down, control down}\n            end try\n          end tell\n        end tell\n      `;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      // Windows maximize\n      const command = `powershell -Command \"(New-Object -ComObject Shell.Application).Windows() | Where-Object {$_.Name -like '*${appName}*'} | ForEach-Object {$_.Maximize()}\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      // Linux maximize using wmctrl\n      await this.executeCommand(`wmctrl -r \"${appName}\" -b add,maximized_vert,maximized_horz`);\n    }\n  }\n  \n  /**\n   * Send keyboard shortcut to application\n   */\n  async sendKeys(appName, keys) {\n    this._init();\n    // First activate the app\n    await this.activateApp(appName);\n    await new Promise(resolve => setTimeout(resolve, 200)); // Small delay\n    \n    if (this.isDarwin) {\n      // Parse the keys for macOS\n      const modifiers = [];\n      const keyParts = keys.toLowerCase().split('+');\n      let mainKey = keyParts[keyParts.length - 1];\n      \n      for (let i = 0; i < keyParts.length - 1; i++) {\n        const mod = keyParts[i];\n        if (mod === 'cmd' || mod === 'command') modifiers.push('command down');\n        if (mod === 'ctrl' || mod === 'control') modifiers.push('control down');\n        if (mod === 'opt' || mod === 'option' || mod === 'alt') modifiers.push('option down');\n        if (mod === 'shift') modifiers.push('shift down');\n      }\n      \n      const modifierString = modifiers.length > 0 ? ` using {${modifiers.join(', ')}}` : '';\n      const script = `tell application \"System Events\" to keystroke \"${mainKey}\"${modifierString}`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      // Use SendKeys on Windows\n      const winKeys = keys.replace('cmd', 'ctrl').replace('option', 'alt');\n      const command = `powershell -Command \"$wshell = New-Object -ComObject wscript.shell; $wshell.SendKeys('${winKeys}')\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      // Use xdotool on Linux\n      const linuxKeys = keys.replace('cmd', 'ctrl').replace('option', 'alt');\n      await this.executeCommand(`xdotool key ${linuxKeys.replace('+', '+')}`);\n    }\n  }\n\n  /**\n   * Type text into application\n   */\n  async typeText(appName, text) {\n    this._init();\n    await this.activateApp(appName);\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    if (this.isDarwin) {\n      const escapedText = text.replace(/\"/g, '\\\\\"');\n      const script = `tell application \"System Events\" to keystroke \"${escapedText}\"`;\n      await this.runAppleScript(script);\n    }\n    else if (this.isWindows) {\n      const escapedText = text.replace(/'/g, \"''\");\n      const command = `powershell -Command \"$wshell = New-Object -ComObject wscript.shell; $wshell.SendKeys('${escapedText}')\"`;\n      await this.executeCommand(command);\n    }\n    else if (this.isLinux) {\n      await this.executeCommand(`xdotool type \"${text}\"`);\n    }\n  }\n\n  /**\n   * macOS-specific: Run AppleScript\n   */\n  async runAppleScript(script) {\n    this._init();\n    if (!this.isDarwin) return '';\n    \n    try {\n      // Escape double quotes for the AppleScript\n      const escapedScript = script.replace(/\"/g, '\\\\\"');\n      // Use double quotes for the command to handle single quotes in AppleScript\n      const command = `osascript -e \"${escapedScript}\"`;\n      const result = await this.executeCommand(command);\n      return result.stdout || '';\n    } catch (error) {\n      // Check if it's a harmless error (like app already quit)\n      if (error.message && (error.message.includes('User canceled') || \n          error.message.includes('Application isn\\'t running'))) {\n        return '';\n      }\n      throw error;\n    }\n  }\n}\n\n// Create singleton platform adapter\nconst platform = new PlatformAdapter();\n\n/**\n * Get a handle to an application (cross-platform)\n * @param {string} identifier - App name, alias, or platform-specific identifier\n * @returns {Promise<Object>} App handle with control methods\n */\nexport async function get(identifier) {\n  // Resolve the app name for current platform\n  const appName = platform.resolveAppName(identifier);\n  \n  // Return null if app not available on this platform\n  if (!appName) {\n    console.warn(`App '${identifier}' is not available on ${platform.platform}`);\n    return null;\n  }\n  \n  // Create app handle with methods\n  return {\n    _identifier: appName,\n    _originalName: identifier,\n    \n    /**\n     * Launch the application\n     * @param {string} [url] - Optional URL to open (for browsers)\n     */\n    async launch(url = null) {\n      return await platform.launchApp(appName, url);\n    },\n    \n    /**\n     * Activate (bring to front) the application\n     */\n    async activate() {\n      return await platform.activateApp(appName);\n    },\n    \n    /**\n     * Quit the application\n     */\n    async quit() {\n      return await platform.quitApp(appName);\n    },\n    \n    /**\n     * Hide the application\n     */\n    async hide() {\n      return await platform.hideApp(appName);\n    },\n    \n    /**\n     * Show/unhide the application\n     */\n    async show() {\n      return await platform.showApp(appName);\n    },\n    \n    /**\n     * Check if application is running\n     */\n    async isRunning() {\n      return await platform.isAppRunning(appName);\n    },\n    \n    /**\n     * Check if application is frontmost (active)\n     */\n    async isFrontmost() {\n      const front = await platform.getFrontmost();\n      return front === appName;\n    },\n    \n    /**\n     * Send keyboard shortcut to the application\n     * @param {string} keys - Keyboard shortcut like \"cmd+s\", \"ctrl+a\"\n     */\n    async sendKeys(keys) {\n      return await platform.sendKeys(appName, keys);\n    },\n    \n    /**\n     * Type text into the application\n     * @param {string} text - Text to type\n     */\n    async type(text) {\n      return await platform.typeText(appName, text);\n    },\n    \n    /**\n     * Maximize/fullscreen the application window\n     */\n    async maximize() {\n      // First ensure app is running and active\n      const launched = await this.launch();\n      await this.activate();\n      \n      // Wait a bit more if we just launched\n      if (launched) {\n        await new Promise(r => setTimeout(r, 500));\n      }\n      \n      return await platform.maximizeApp(appName);\n    },\n    \n    /**\n     * Open app with optional URL or callback\n     * @param {string|Function} [urlOrCallback] - URL to open (for browsers) or callback function\n     */\n    async open(urlOrCallback) {\n      // Handle URL string (for browsers and URL-capable apps)\n      if (typeof urlOrCallback === 'string') {\n        const url = urlOrCallback;\n        const launched = await this.launch(url);\n        await this.activate();\n        \n        // If just launched, ensure it's ready\n        if (launched) {\n          await platform.waitForApp(appName);\n        }\n        \n        return this; // Allow chaining\n      }\n      \n      // Handle callback function (original behavior)\n      const callback = urlOrCallback;\n      const launched = await this.launch();\n      await this.activate();\n      \n      // If just launched, ensure it's ready\n      if (launched) {\n        await platform.waitForApp(appName);\n      }\n      \n      if (callback && typeof callback === 'function') {\n        return await callback(this);\n      }\n      \n      return this; // Allow chaining\n    }\n  };\n}\n\n/**\n * List all running applications\n * @returns {Promise<Array>} List of running app names\n */\nexport async function list() {\n  return await platform.listApps();\n}\n\n/**\n * Get the frontmost (active) application\n * @returns {Promise<Object>} App handle for the active app\n */\nexport async function frontmost() {\n  const name = await platform.getFrontmost();\n  if (!name) return null;\n  return get(name);\n}\n\n/**\n * Get list of known app aliases\n * @returns {Array} List of available app aliases\n */\nexport function aliases() {\n  return Object.keys(APP_REGISTRY);\n}\n\n/**\n * Check if an app alias is available on current platform\n * @param {string} alias - App alias to check\n * @returns {boolean} True if available on current platform\n */\nexport function isAvailable(alias) {\n  platform._init();\n  const lowerName = alias.toLowerCase();\n  if (!APP_REGISTRY[lowerName]) return false;\n  return APP_REGISTRY[lowerName][platform.platform] !== null;\n}\n\nexport default {\n  get,\n  list,\n  frontmost,\n  aliases,\n  isAvailable\n};",
  "computer/context.js": "// Context Module - Captures current system state for developer productivity\n// Provides easy access to clipboard, selection, and screen content\n\nimport { exec } from \"../core/system.js\";\n\n// Helper to get selected text\n// Uses multiple strategies depending on platform\nasync function getSelectedText() {\n  try {\n    // Strategy 1: Try to get selection via OS commands\n    if (Deno.build.os === \"darwin\") {\n      // On macOS, try using osascript to get selection from frontmost app\n      try {\n        const result = await exec(\n          `osascript -e 'tell application \"System Events\" to keystroke \"c\" using command down' && pbpaste`\n        );\n        if (result.success && result.stdout.trim()) {\n          return result.stdout.trim();\n        }\n      } catch {\n        // Fall through to next strategy\n      }\n    } else if (Deno.build.os === \"linux\") {\n      // On Linux, try xclip or xsel for primary selection\n      try {\n        const result = await exec(\"xclip -o -selection primary 2>/dev/null || xsel -o -p 2>/dev/null\");\n        if (result.success && result.stdout.trim()) {\n          return result.stdout.trim();\n        }\n      } catch {\n        // Fall through to next strategy\n      }\n    } else if (Deno.build.os === \"windows\") {\n      // On Windows, selection is harder to get directly\n      // Fall through to clipboard strategy\n    }\n    \n    // Strategy 2: Return null if no selection available\n    // This is better than returning stale clipboard data\n    return null;\n  } catch (error) {\n    console.error(\"Failed to get selection:\", error.message);\n    return null;\n  }\n}\n\n// Extract text from image using OCR\n\n// Context namespace - provides current state\nexport const context = {\n  // Get currently selected text\n  get selection() {\n    // This is synchronous but internally uses cached async result\n    // For now, we'll make it async and users need to await\n    return getSelectedText();\n  },\n  \n  // Screen context object\n  screen: {\n    // Get current screen as image data - SYNCHRONOUS\n    get image() {\n      try {\n        // Capture to temp file and read as bytes\n        const tempPath = `/tmp/hlvm_screen_${Date.now()}.png`;\n        \n        // Use screencapture command directly for sync operation\n        if (Deno.build.os === \"darwin\") {\n          const p = new Deno.Command(\"screencapture\", {\n            args: [\"-x\", \"-C\", tempPath] // -x: no sound, -C: capture cursor\n          });\n          const output = p.outputSync();\n          if (!output.success) {\n            throw new Error(\"Screen capture failed\");\n          }\n        } else if (Deno.build.os === \"linux\") {\n          // Try various Linux screenshot tools\n          const tools = [\n            { cmd: \"import\", args: [\"-window\", \"root\", tempPath] }, // ImageMagick\n            { cmd: \"scrot\", args: [tempPath] },\n            { cmd: \"gnome-screenshot\", args: [\"-f\", tempPath] }\n          ];\n          \n          let captured = false;\n          for (const tool of tools) {\n            try {\n              const p = new Deno.Command(tool.cmd, { args: tool.args });\n              const output = p.outputSync();\n              if (output.success) {\n                captured = true;\n                break;\n              }\n            } catch {\n              // Try next tool\n            }\n          }\n          \n          if (!captured) {\n            throw new Error(\"No screenshot tool available\");\n          }\n        } else if (Deno.build.os === \"windows\") {\n          // Windows: Use PowerShell screenshot\n          const script = `\n            Add-Type -AssemblyName System.Windows.Forms\n            Add-Type -AssemblyName System.Drawing\n            $screen = [System.Windows.Forms.SystemInformation]::VirtualScreen\n            $bitmap = New-Object System.Drawing.Bitmap $screen.Width, $screen.Height\n            $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n            $graphics.CopyFromScreen($screen.Left, $screen.Top, 0, 0, $bitmap.Size)\n            $bitmap.Save('${tempPath}')\n          `;\n          const p = new Deno.Command(\"powershell\", {\n            args: [\"-NoProfile\", \"-Command\", script]\n          });\n          const output = p.outputSync();\n          if (!output.success) {\n            throw new Error(\"Screen capture failed\");\n          }\n        }\n        \n        // Read the captured image\n        const imageData = Deno.readFileSync(tempPath);\n        \n        // Clean up temp file\n        try { Deno.removeSync(tempPath); } catch {}\n        \n        return imageData;\n      } catch (error) {\n        console.error(\"Failed to capture screen:\", error.message);\n        return new Uint8Array();\n      }\n    },\n    \n    // Get text from current screen via OCR\n    get text() {\n      try {\n        // Get screen image first\n        const imageData = this.image;\n        if (imageData.length === 0) return \"\";\n        \n        // Extract text via OCR (this would be async in real implementation)\n        // For now return a sync placeholder\n        return \"[Screen text extraction pending implementation]\";\n      } catch (error) {\n        console.error(\"Failed to extract screen text:\", error.message);\n        return \"\";\n      }\n    }\n  }\n};\n\n// Make selection truly async since it needs to run commands\nObject.defineProperty(context, 'selection', {\n  get() {\n    return getSelectedText();\n  },\n  enumerable: true,\n  configurable: false\n});\n\n// Re-export for convenience\nexport default context;",
  "computer/keyboard.js": "// Keyboard module - Cross-platform keyboard automation with unified array format\n// Array format: [\"cmd\", \"shift\", \"a\"] where last element is the key, rest are modifiers\n\nimport { platformCommand, PowerShellTemplates, initializeDocs, handleMacOSPermission } from \"../core/utils.js\";\nimport { decode } from \"../core/platform.js\";\n\n// Global keyboard event listeners storage\nconst keyListeners = new Map();\n\n// Key mappings for cross-platform support\nconst KEY_MAP = {\n  // Common keys\n  \"enter\": { darwin: \"return\", windows: \"{ENTER}\", linux: \"Return\" },\n  \"return\": { darwin: \"return\", windows: \"{ENTER}\", linux: \"Return\" },\n  \"tab\": { darwin: \"tab\", windows: \"{TAB}\", linux: \"Tab\" },\n  \"delete\": { darwin: \"delete\", windows: \"{DEL}\", linux: \"Delete\" },\n  \"backspace\": { darwin: \"delete\", windows: \"{BACKSPACE}\", linux: \"BackSpace\" },\n  \"escape\": { darwin: \"escape\", windows: \"{ESC}\", linux: \"Escape\" },\n  \"esc\": { darwin: \"escape\", windows: \"{ESC}\", linux: \"Escape\" },\n  \"space\": { darwin: \"space\", windows: \" \", linux: \"space\" },\n  \"up\": { darwin: \"up arrow\", windows: \"{UP}\", linux: \"Up\" },\n  \"down\": { darwin: \"down arrow\", windows: \"{DOWN}\", linux: \"Down\" },\n  \"left\": { darwin: \"left arrow\", windows: \"{LEFT}\", linux: \"Left\" },\n  \"right\": { darwin: \"right arrow\", windows: \"{RIGHT}\", linux: \"Right\" },\n  \"home\": { darwin: \"home\", windows: \"{HOME}\", linux: \"Home\" },\n  \"end\": { darwin: \"end\", windows: \"{END}\", linux: \"End\" },\n  \"pageup\": { darwin: \"page up\", windows: \"{PGUP}\", linux: \"Page_Up\" },\n  \"pagedown\": { darwin: \"page down\", windows: \"{PGDN}\", linux: \"Page_Down\" }\n};\n\n// Helper to escape text for keyboard input\nfunction escapeKeyboard(text) {\n  const os = globalThis.Deno.build.os;\n  if (os === \"darwin\") {\n    return text.replace(/[\"\\\\]/g, '\\\\$&');\n  } else if (os === \"windows\") {\n    // PowerShell SendKeys special characters\n    return text.replace(/[+^%~(){}[\\]]/g, '{$&}');\n  }\n  return text;\n}\n\n// Helper to normalize keys array\nfunction normalizeKeys(keys) {\n  // Only accept array format\n  if (!Array.isArray(keys)) {\n    throw new Error('Keyboard functions require array format: [\"cmd\", \"s\"] or [\"enter\"]');\n  }\n  \n  // Normalize modifier names\n  return keys.map(k => {\n    const lower = k.toLowerCase();\n    // Normalize common variations\n    if (lower === 'command' || lower === 'meta' || lower === 'super') return 'cmd';\n    if (lower === 'control') return 'ctrl';\n    if (lower === 'option') return 'alt';\n    return lower;\n  });\n}\n\n// Get string representation of keys for Map key\nfunction getKeyString(keys) {\n  const normalized = normalizeKeys(keys);\n  return normalized.sort().join('+');\n}\n\nexport async function type(text) {\n  const escapedText = escapeKeyboard(text);\n  \n  try {\n    const result = await platformCommand({\n      darwin: {\n        cmd: \"osascript\",\n        args: [\"-e\", `tell application \"System Events\" to keystroke \"${escapedText}\"`]\n      },\n      windows: {\n        script: PowerShellTemplates.sendKeys(escapedText)\n      },\n      linux: [\n        { cmd: \"xdotool\", args: [\"type\", text] },\n        { cmd: \"ydotool\", args: [\"type\", text] }\n      ]\n    });\n    \n    // Check for macOS permission errors\n    if (!result.success && result.stderr) {\n      if (handleMacOSPermission({ stderr: result.stderr })) {\n        throw new Error(\"Keyboard control requires accessibility permissions\");\n      }\n      throw new Error(`Keyboard type failed: ${result.stderr}`);\n    }\n    \n    return result;\n  } catch (error) {\n    if (handleMacOSPermission(error)) {\n      throw new Error(\"Keyboard control requires accessibility permissions. Grant access in System Settings.\");\n    }\n    throw error;\n  }\n}\n\n// Updated press function that accepts array format only\nexport async function press(keys) {\n  // Only array format is supported\n  const normalized = normalizeKeys(keys);\n  \n  // Extract key and modifiers from normalized array\n  const key = normalized[normalized.length - 1];\n  const modifiers = normalized.slice(0, -1);\n  \n  // Normalize key name\n  const normalizedKey = key.toLowerCase();\n  const keyMapping = KEY_MAP[normalizedKey] || {\n    darwin: key,\n    windows: key,\n    linux: key\n  };\n  \n  const os = globalThis.Deno.build.os;\n  \n  // Build platform-specific commands\n  if (os === \"darwin\") {\n    // macOS: osascript with modifiers\n    const mods = [];\n    if (modifiers.includes('cmd')) mods.push(\"command down\");\n    if (modifiers.includes('ctrl')) mods.push(\"control down\");\n    if (modifiers.includes('alt')) mods.push(\"option down\");\n    if (modifiers.includes('shift')) mods.push(\"shift down\");\n    \n    const keyName = keyMapping.darwin;\n    const script = mods.length > 0\n      ? `tell application \"System Events\" to keystroke \"${keyName}\" using {${mods.join(\", \")}}`\n      : `tell application \"System Events\" to keystroke \"${keyName}\"`;\n    \n    try {\n      const result = await platformCommand({\n        darwin: { cmd: \"osascript\", args: [\"-e\", script] }\n      });\n      \n      if (!result.success) {\n        handleMacOSPermission({ stderr: result.stderr });\n        throw new Error(`Keyboard press failed: ${result.stderr}`);\n      }\n    } catch (error) {\n      if (handleMacOSPermission(error)) {\n        throw new Error(\"Keyboard control requires accessibility permissions\");\n      }\n      throw error;\n    }\n    \n  } else if (os === \"windows\") {\n    // Windows: PowerShell SendKeys with modifiers\n    let keysStr = \"\";\n    if (modifiers.includes('ctrl')) keysStr += \"^\";\n    if (modifiers.includes('alt')) keysStr += \"%\";\n    if (modifiers.includes('shift')) keysStr += \"+\";\n    keysStr += keyMapping.windows;\n    \n    await platformCommand({\n      windows: { script: PowerShellTemplates.sendKeys(keysStr) }\n    });\n    \n  } else {\n    // Linux: xdotool or ydotool\n    const linuxKeys = [];\n    if (modifiers.includes('ctrl')) linuxKeys.push(\"ctrl\");\n    if (modifiers.includes('alt')) linuxKeys.push(\"alt\");\n    if (modifiers.includes('shift')) linuxKeys.push(\"shift\");\n    if (modifiers.includes('cmd')) linuxKeys.push(\"super\");\n    linuxKeys.push(keyMapping.linux);\n    \n    await platformCommand({\n      linux: [\n        { cmd: \"xdotool\", args: [\"key\", linuxKeys.join(\"+\")] },\n        { cmd: \"ydotool\", args: [\"key\", ...linuxKeys] }\n      ]\n    });\n  }\n}\n\n// Register a global keyboard shortcut listener\nexport function onKeyPress(keys, callback) {\n  const keyString = getKeyString(keys);\n  \n  // Store the callback\n  if (!keyListeners.has(keyString)) {\n    keyListeners.set(keyString, []);\n  }\n  keyListeners.get(keyString).push(callback);\n  \n  // Platform-specific global hotkey registration would go here\n  // For now, this is a stub that stores the callbacks for future implementation\n  console.warn('Global keyboard shortcuts not yet implemented. Callback registered for future use.');\n  \n  return true;\n}\n\n// Unregister a global keyboard shortcut listener\nexport function offKeyPress(keys, callback) {\n  const keyString = getKeyString(keys);\n  \n  if (!keyListeners.has(keyString)) {\n    return false;\n  }\n  \n  const callbacks = keyListeners.get(keyString);\n  \n  if (callback) {\n    // Remove specific callback\n    const index = callbacks.indexOf(callback);\n    if (index > -1) {\n      callbacks.splice(index, 1);\n    }\n    \n    // Clean up if no callbacks left\n    if (callbacks.length === 0) {\n      keyListeners.delete(keyString);\n    }\n  } else {\n    // Remove all callbacks for this key combination\n    keyListeners.delete(keyString);\n  }\n  \n  // Platform-specific deregistration would go here\n  \n  return true;\n}\n\n// List all registered keyboard shortcuts\nexport function listKeyListeners() {\n  const result = [];\n  for (const [keyString, callbacks] of keyListeners.entries()) {\n    result.push({\n      keys: keyString.split('+'),\n      callbackCount: callbacks.length\n    });\n  }\n  return result;\n}\n\n// Initialize docs on module load\ninitializeDocs({ type, press, onKeyPress, offKeyPress, listKeyListeners }, {\n  type: `type(text)\nTypes text using keyboard\nParameters: text - string to type`,\n  \n  press: `press(keys)\nPresses key combination\nParameters: keys - array format [\"cmd\", \"shift\", \"a\"]`,\n  \n  onKeyPress: `onKeyPress(keys, callback)\nRegisters global keyboard shortcut listener\nParameters: keys - array format, callback - function`,\n  \n  offKeyPress: `offKeyPress(keys, callback?)\nUnregisters keyboard shortcut listener\nParameters: keys - array format, callback - optional specific callback`,\n  \n  listKeyListeners: `listKeyListeners()\nLists all registered keyboard shortcuts\nReturns: array of {keys, callbackCount}`\n});",
  "computer/mouse.js": "// Mouse module - Cross-platform mouse automation\n\nimport { platformCommand, PowerShellTemplates, initializeDocs } from \"../core/utils.js\";\n\n/**\n * Move mouse cursor to specified position\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @returns {Promise<void>}\n */\nexport async function move(x, y) {\n  const os = globalThis.Deno.build.os;\n  \n  if (os === \"darwin\") {\n    try {\n      await platformCommand({\n        darwin: { cmd: \"cliclick\", args: [`m:${x},${y}`] }\n      });\n    } catch {\n      // Fallback to Python/Quartz\n      const script = `\nimport Quartz\nQuartz.CGWarpMouseCursorPosition((${x}, ${y}))`;\n      await platformCommand({\n        darwin: { cmd: \"python3\", args: [\"-c\", script] }\n      });\n    }\n  } else {\n    await platformCommand({\n      windows: { script: PowerShellTemplates.setCursorPosition(x, y) },\n      linux: [\n        { cmd: \"xdotool\", args: [\"mousemove\", String(x), String(y)] },\n        { cmd: \"ydotool\", args: [\"mousemove\", String(x), String(y)] }\n      ]\n    });\n  }\n}\n\n/**\n * Click mouse button at position\n * @param {number|null} x - X coordinate (null for current position)\n * @param {number|null} y - Y coordinate (null for current position)\n * @param {string} button - Button to click (left|right|middle)\n * @returns {Promise<void>}\n */\nexport async function click(x = null, y = null, button = \"left\") {\n  // Move to position if specified\n  if (x !== null && y !== null) {\n    await move(x, y);\n  }\n  \n  const os = globalThis.Deno.build.os;\n  \n  if (os === \"darwin\") {\n    const buttonMap = { \"left\": \"c\", \"right\": \"rc\", \"middle\": \"mc\" };\n    const args = x !== null && y !== null \n      ? [`${buttonMap[button]}:${x},${y}`]\n      : [buttonMap[button]];\n    \n    try {\n      await platformCommand({ darwin: { cmd: \"cliclick\", args } });\n    } catch {\n      // Fallback to Python/Quartz\n      await clickWithQuartz(x, y, button);\n    }\n  } else if (os === \"windows\") {\n    const moveScript = x !== null && y !== null \n      ? PowerShellTemplates.setCursorPosition(x, y)\n      : \"\";\n    await platformCommand({\n      windows: { script: moveScript + PowerShellTemplates.mouseClick(button) }\n    });\n  } else {\n    // Linux\n    const buttonMap = { \"left\": \"1\", \"middle\": \"2\", \"right\": \"3\" };\n    const buttonNum = buttonMap[button] || \"1\";\n    \n    if (x !== null && y !== null) {\n      await platformCommand({\n        linux: [\n          { cmd: \"xdotool\", args: [\"mousemove\", String(x), String(y), \"click\", buttonNum] },\n          { cmd: \"ydotool\", args: [\"mousemove\", String(x), String(y), \"click\", buttonNum] }\n        ]\n      });\n    } else {\n      await platformCommand({\n        linux: [\n          { cmd: \"xdotool\", args: [\"click\", buttonNum] },\n          { cmd: \"ydotool\", args: [\"click\", buttonNum] }\n        ]\n      });\n    }\n  }\n}\n\n/**\n * Get current mouse position\n * @returns {Promise<{x: number, y: number}>} Current position\n */\nexport async function position() {\n  let result;\n  const os = globalThis.Deno.build.os;\n  \n  if (os === \"darwin\") {\n    try {\n      result = await platformCommand({ darwin: { cmd: \"cliclick\", args: [\"p\"] } });\n    } catch {\n      // Fallback to Python/Quartz\n      const script = `\nimport Quartz\npos = Quartz.NSEvent.mouseLocation()\nprint(f\"{int(pos.x)},{int(pos.y)}\")`;\n      result = await platformCommand({ darwin: { cmd: \"python3\", args: [\"-c\", script] } });\n    }\n  } else {\n    result = await platformCommand({\n      windows: { script: PowerShellTemplates.getCursorPosition },\n      linux: [\n        { cmd: \"xdotool\", args: [\"getmouselocation\"] },\n        { cmd: \"ydotool\", args: [\"mousemove\", \"--get\"] }\n      ]\n    });\n  }\n  \n  // Parse position from result\n  const output = result.stdout.trim();\n  \n  // Linux xdotool format: \"x:123 y:456 ...\"\n  if (output.includes(\"x:\") && output.includes(\"y:\")) {\n    const x = parseInt(output.match(/x:(\\d+)/)?.[1] || \"0\");\n    const y = parseInt(output.match(/y:(\\d+)/)?.[1] || \"0\");\n    return { x, y };\n  }\n  \n  // Common format: \"123,456\"\n  if (output.includes(\",\")) {\n    const [x, y] = output.split(\",\").map(n => parseInt(n));\n    return { x, y };\n  }\n  \n  // ydotool format: \"123 456\"\n  const parts = output.split(/\\s+/).map(n => parseInt(n));\n  if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {\n    return { x: parts[0], y: parts[1] };\n  }\n  \n  throw new Error(\"Failed to parse mouse position\");\n}\n\n/**\n * Double click at position\n * @param {number|null} x - X coordinate\n * @param {number|null} y - Y coordinate\n * @returns {Promise<void>}\n */\nexport async function doubleClick(x = null, y = null) {\n  await click(x, y);\n  await new Promise(r => setTimeout(r, 50));\n  await click(x, y);\n}\n\n/**\n * Drag from one position to another\n * @param {number} fromX - Start X coordinate\n * @param {number} fromY - Start Y coordinate\n * @param {number} toX - End X coordinate\n * @param {number} toY - End Y coordinate\n * @returns {Promise<void>}\n */\nexport async function drag(fromX, fromY, toX, toY) {\n  const os = globalThis.Deno.build.os;\n  \n  if (os === \"darwin\") {\n    try {\n      await platformCommand({\n        darwin: { cmd: \"cliclick\", args: [`dd:${fromX},${fromY}`, `du:${toX},${toY}`] }\n      });\n    } catch {\n      // Fallback to basic move and click\n      await move(fromX, fromY);\n      await click(fromX, fromY);\n      await move(toX, toY);\n      await click(toX, toY);\n    }\n  } else {\n    await platformCommand({\n      windows: {\n        script: `\n${PowerShellTemplates.addWindowsTypes}\nAdd-Type @\"\n  using System;\n  using System.Runtime.InteropServices;\n  public class Mouse {\n    [DllImport(\"user32.dll\")]\n    public static extern void mouse_event(int dwFlags, int dx, int dy, int cButtons, int dwExtraInfo);\n  }\n\"@\n\n# Move to start position\n[System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${fromX}, ${fromY})\n# Mouse down\n[Mouse]::mouse_event(0x0002, 0, 0, 0, 0)\n# Move to end position\n[System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${toX}, ${toY})\n# Mouse up\n[Mouse]::mouse_event(0x0004, 0, 0, 0, 0)`\n    },\n    linux: [\n      { \n        cmd: \"xdotool\", \n        args: [\"mousemove\", String(fromX), String(fromY), \"mousedown\", \"1\",\n                \"mousemove\", String(toX), String(toY), \"mouseup\", \"1\"]\n      },\n      { \n        cmd: \"ydotool\", \n        args: [\"mousemove\", String(fromX), String(fromY), \"mousedown\", \"1\",\n                \"mousemove\", String(toX), String(toY), \"mouseup\", \"1\"]\n      }\n    ]\n    });\n  }\n}\n\n// Helper function for macOS Quartz fallback\nasync function clickWithQuartz(x, y, button) {\n  const script = `\nimport Quartz\n\n# Get current position if not specified\n${x === null ? `\npos = Quartz.NSEvent.mouseLocation()\nx, y = pos.x, pos.y\n` : `x, y = ${x}, ${y}`}\n\nbutton_map = {\n  \"left\": Quartz.kCGMouseButtonLeft,\n  \"right\": Quartz.kCGMouseButtonRight,\n  \"middle\": Quartz.kCGMouseButtonCenter\n}\n\nevent_down = {\n  \"left\": Quartz.kCGEventLeftMouseDown,\n  \"right\": Quartz.kCGEventRightMouseDown,\n  \"middle\": Quartz.kCGEventOtherMouseDown\n}\n\nevent_up = {\n  \"left\": Quartz.kCGEventLeftMouseUp,\n  \"right\": Quartz.kCGEventRightMouseUp,\n  \"middle\": Quartz.kCGEventOtherMouseUp\n}\n\nbutton_type = button_map.get(\"${button}\", button_map[\"left\"])\ndown_type = event_down.get(\"${button}\", event_down[\"left\"])\nup_type = event_up.get(\"${button}\", event_up[\"left\"])\n\nevent = Quartz.CGEventCreateMouseEvent(None, down_type, (x, y), button_type)\nQuartz.CGEventPost(Quartz.kCGHIDEventTap, event)\n\nevent = Quartz.CGEventCreateMouseEvent(None, up_type, (x, y), button_type)\nQuartz.CGEventPost(Quartz.kCGHIDEventTap, event)`;\n  \n  await platformCommand({ darwin: { cmd: \"python3\", args: [\"-c\", script] } });\n}\n\n// Initialize docs on module load\ninitializeDocs({ move, click, position, doubleClick, drag }, {\n  move: `move(x, y)\nMoves mouse cursor to specified position\nParameters: x, y - coordinates`,\n  \n  click: `click(x?, y?, button?)\nClicks mouse button at position\nParameters: x, y - coordinates (optional), button - left|right|middle`,\n  \n  position: `position()\nGets current mouse position\nReturns: {x, y} coordinates`,\n  \n  doubleClick: `doubleClick(x?, y?)\nDouble clicks at position\nParameters: x, y - coordinates (optional)`,\n  \n  drag: `drag(fromX, fromY, toX, toY)\nDrags from one position to another\nParameters: fromX, fromY, toX, toY - start and end coordinates`\n});",
  "computer/notification.js": "// Notification module - Cross-platform UI dialogs and notifications\n\nimport { isDarwin, isWindows, escapeShell, decode, powershell, PS, ERRORS } from \"../core/platform.js\";\nimport { initializeDocs } from \"../core/utils.js\";\n\n// DRY: Generic Linux dialog handler\nasync function linuxDialog(type, message, title, defaultValue = \"\") {\n  const tools = [\n    {\n      cmd: \"zenity\",\n      args: {\n        alert: [\"--info\", \"--text\", message, \"--title\", title],\n        confirm: [\"--question\", \"--text\", message, \"--title\", title],\n        prompt: [\"--entry\", \"--text\", message, \"--title\", title, ...(defaultValue ? [\"--entry-text\", defaultValue] : [])]\n      }\n    },\n    {\n      cmd: \"kdialog\",\n      args: {\n        alert: [\"--msgbox\", message, \"--title\", title],\n        confirm: [\"--yesno\", message, \"--title\", title],\n        prompt: [\"--inputbox\", message, defaultValue, \"--title\", title]\n      }\n    }\n  ];\n  \n  for (const tool of tools) {\n    try {\n      const result = await new Deno.Command(tool.cmd, {\n        args: tool.args[type]\n      }).output();\n      \n      if (type === \"alert\") return;\n      if (type === \"confirm\") return result.code === 0;\n      if (type === \"prompt\") return result.code === 0 ? decode(result.stdout).trim() : null;\n    } catch {\n      // Try next tool\n    }\n  }\n  \n  // Fallback\n  if (type === \"alert\") {\n    await notify(message, title);\n  } else {\n    console.error(ERRORS.LINUX_DIALOG);\n    return type === \"confirm\" ? false : null;\n  }\n}\n\n// DRY: Generic osascript handler\nasync function osascriptDialog(type, message, title, defaultValue = \"\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  const escapedDefault = escapeShell(defaultValue);\n  \n  const scripts = {\n    alert: `display alert \"${escapedTitle}\" message \"${escapedMessage}\"`,\n    confirm: `\n      button returned of (display dialog \"${escapedMessage}\" ¬\n        with title \"${escapedTitle}\" ¬\n        buttons {\"Cancel\", \"OK\"} ¬\n        default button \"OK\")\n    `,\n    prompt: `\n      text returned of (display dialog \"${escapedMessage}\" ¬\n        with title \"${escapedTitle}\" ¬\n        default answer \"${escapedDefault}\" ¬\n        buttons {\"Cancel\", \"OK\"} ¬\n        default button \"OK\")\n    `\n  };\n  \n  try {\n    const result = await new Deno.Command(\"osascript\", { \n      args: [\"-e\", scripts[type]] \n    }).output();\n    \n    if (type === \"alert\") return;\n    if (type === \"confirm\") return decode(result.stdout).trim() === \"OK\";\n    if (type === \"prompt\") return decode(result.stdout).trim();\n  } catch {\n    return type === \"confirm\" ? false : null;\n  }\n}\n\n// DRY: Generic PowerShell dialog handler\nasync function windowsDialog(type, message, title, defaultValue = \"\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  const escapedDefault = escapeShell(defaultValue);\n  \n  const scripts = {\n    alert: `\n      ${PS.forms}\n      [System.Windows.Forms.MessageBox]::Show(\"${escapedMessage}\", \"${escapedTitle}\")\n    `,\n    confirm: `\n      ${PS.forms}\n      $result = [System.Windows.Forms.MessageBox]::Show(\n        \"${escapedMessage}\", \n        \"${escapedTitle}\", \n        [System.Windows.Forms.MessageBoxButtons]::YesNo\n      )\n      if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {\n        Write-Host \"true\"\n      } else {\n        Write-Host \"false\"\n      }\n    `,\n    prompt: `\n      ${PS.visualBasic}\n      $result = [Microsoft.VisualBasic.Interaction]::InputBox(\n        \"${escapedMessage}\", \n        \"${escapedTitle}\", \n        \"${escapedDefault}\"\n      )\n      if ($result -eq \"\") {\n        if ($LastExitCode -eq 0) { Write-Host \"\" }\n      } else {\n        Write-Host $result\n      }\n    `\n  };\n  \n  const { stdout } = await powershell(scripts[type]);\n  \n  if (type === \"alert\") return;\n  if (type === \"confirm\") return decode(stdout).trim() === \"true\";\n  if (type === \"prompt\") return decode(stdout).trim();\n}\n\n// Public API - Now much cleaner\nexport async function alert(message, title = \"Alert\") {\n  if (platform.isDarwin) {\n    return osascriptDialog(\"alert\", message, title);\n  } else if (platform.isWindows) {\n    return windowsDialog(\"alert\", message, title);\n  } else {\n    return linuxDialog(\"alert\", message, title);\n  }\n}\n\nexport async function confirm(message, title = \"Confirm\") {\n  if (platform.isDarwin) {\n    return osascriptDialog(\"confirm\", message, title);\n  } else if (platform.isWindows) {\n    return windowsDialog(\"confirm\", message, title);\n  } else {\n    return linuxDialog(\"confirm\", message, title);\n  }\n}\n\nexport async function prompt(message, defaultValue = \"\", title = \"Input\") {\n  if (platform.isDarwin) {\n    return osascriptDialog(\"prompt\", message, title, defaultValue);\n  } else if (platform.isWindows) {\n    return windowsDialog(\"prompt\", message, title, defaultValue);\n  } else {\n    return linuxDialog(\"prompt\", message, title, defaultValue);\n  }\n}\n\nexport async function notify(message, title = \"Notification\", subtitle = \"\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  \n  if (platform.isDarwin) {\n    let script = `display notification \"${escapedMessage}\" with title \"${escapedTitle}\"`;\n    if (subtitle) {\n      script += ` subtitle \"${escapeShell(subtitle)}\"`;\n    }\n    await new Deno.Command(\"osascript\", { args: [\"-e\", script] }).output();\n    \n  } else if (platform.isWindows) {\n    // Windows toast notification\n    try {\n      const script = `\n        [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null\n        [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null\n        \n        $template = @\"\n        <toast>\n          <visual>\n            <binding template=\"ToastGeneric\">\n              <text>${escapedTitle}</text>\n              <text>${escapedMessage}</text>\n            </binding>\n          </visual>\n        </toast>\n\"@\n        $xml = New-Object Windows.Data.Xml.Dom.XmlDocument\n        $xml.LoadXml($template)\n        $toast = New-Object Windows.UI.Notifications.ToastNotification $xml\n        [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier(\"HLVM\").Show($toast)\n      `;\n      await powershell(script);\n    } catch {\n      await alert(message, title);\n    }\n    \n  } else {\n    // Linux notify-send\n    try {\n      await new Deno.Command(\"notify-send\", {\n        args: [title, message]\n      }).output();\n    } catch {\n      console.error(ERRORS.LINUX_NOTIFY);\n    }\n  }\n}\n\n\n// Initialize docs on module load\ninitializeDocs({ alert, confirm, prompt, notify }, {\n  alert: `alert(message, title?)\nShows alert dialog\nParameters: message, title (optional)`,\n  \n  confirm: `confirm(message, title?)\nShows confirmation dialog\nParameters: message, title (optional)\nReturns: true/false`,\n  \n  prompt: `prompt(message, defaultValue?, title?)\nShows input dialog\nParameters: message, defaultValue (optional), title (optional)\nReturns: user input or null`,\n  \n  notify: `notify(message, title?, subtitle?)\nShows system notification\nParameters: message, title (optional), subtitle (optional for macOS)`\n});\n",
  "computer/screen.js": "// Screen module - Cross-platform screen capture\n\nimport { isDarwin, isWindows, tempDir, pathSep, decode } from \"../core/platform.js\";\n\nexport async function capture(output = null, options = {}) {\n  // Use platform-specific temp file if no output specified\n  if (!output) {\n    const tempDirectory = tempDir();\n    const timestamp = Date.now();\n    output = `${tempDirectory}${pathSep}screenshot-${timestamp}.png`;\n  }\n  \n  if (isDarwin) {\n    // macOS: screencapture (built-in)\n    const args = [\"-x\"]; // No sound\n    \n    if (options.interactive) {\n      args.push(\"-i\"); // Interactive mode (user selects window)\n    }\n    if (options.selection || options.select) {\n      args.push(\"-s\"); // Selection mode (user draws rectangle)\n    }\n    if (options.window) {\n      args.push(\"-w\"); // Window selection mode\n    }\n    if (options.delay) {\n      args.push(\"-T\", String(options.delay)); // Delay in seconds\n    }\n    \n    args.push(output);\n    \n    const { success } = await new Deno.Command(\"screencapture\", { args }).output();\n    if (!success) throw new Error(\"Screenshot failed\");\n    \n  } else if (isWindows) {\n    // Windows: PowerShell screenshot (built-in)\n    const script = `\n      Add-Type -AssemblyName System.Windows.Forms\n      Add-Type -AssemblyName System.Drawing\n      \n      $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n      $bounds = $screen.Bounds\n      $bitmap = New-Object System.Drawing.Bitmap($bounds.Width, $bounds.Height)\n      $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n      $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)\n      $bitmap.Save(\"${output.replace(/\\\\/g, '\\\\\\\\')}\")\n      $graphics.Dispose()\n      $bitmap.Dispose()\n    `;\n    \n    const { success } = await new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", script]\n    }).output();\n    if (!success) throw new Error(\"Screenshot failed\");\n    \n  } else {\n    // Linux: Try multiple screenshot tools\n    const tools = [\n      {\n        cmd: \"scrot\",\n        args: options.selection ? [\"-s\", output] : [output]\n      },\n      {\n        cmd: \"gnome-screenshot\",\n        args: options.selection \n          ? [\"-a\", \"-f\", output]\n          : [\"-f\", output]\n      },\n      {\n        cmd: \"spectacle\",\n        args: options.selection\n          ? [\"-r\", \"-b\", \"-n\", \"-o\", output]\n          : [\"-b\", \"-n\", \"-o\", output]\n      },\n      {\n        cmd: \"import\", // ImageMagick\n        args: [output]\n      }\n    ];\n    \n    let captured = false;\n    for (const tool of tools) {\n      try {\n        const { success } = await new Deno.Command(tool.cmd, {\n          args: tool.args\n        }).output();\n        if (success) {\n          captured = true;\n          break;\n        }\n      } catch {\n        // Try next tool\n      }\n    }\n    \n    if (!captured) {\n      throw new Error(\n        \"Screenshot failed. Install one of: scrot, gnome-screenshot, spectacle, or imagemagick\"\n      );\n    }\n  }\n  \n  return output;\n}\n\n// Get screen dimensions (cross-platform)\nexport async function getScreenSize() {\n  if (isDarwin) {\n    // macOS: Use system_profiler\n    const { stdout } = await new Deno.Command(\"system_profiler\", {\n      args: [\"SPDisplaysDataType\", \"-json\"]\n    }).output();\n    \n    try {\n      const data = JSON.parse(decode(stdout));\n      const display = data.SPDisplaysDataType[0].spdisplays_ndrvs[0];\n      const resolution = display._spdisplays_resolution.match(/(\\d+) x (\\d+)/);\n      if (resolution) {\n        return {\n          width: parseInt(resolution[1]),\n          height: parseInt(resolution[2])\n        };\n      }\n    } catch {}\n    \n  } else if (isWindows) {\n    // Windows: Use PowerShell\n    const script = `\n      Add-Type -AssemblyName System.Windows.Forms\n      $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n      Write-Host \"$($screen.Bounds.Width),$($screen.Bounds.Height)\"\n    `;\n    \n    const { stdout } = await new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", script]\n    }).output();\n    \n    const [width, height] = decode(stdout).trim().split(\",\");\n    return {\n      width: parseInt(width),\n      height: parseInt(height)\n    };\n    \n  } else {\n    // Linux: Try xrandr or xdpyinfo\n    try {\n      const { stdout } = await new Deno.Command(\"xrandr\", {\n        args: [\"--current\"]\n      }).output();\n      \n      const output = decode(stdout);\n      const match = output.match(/primary (\\d+)x(\\d+)/);\n      if (match) {\n        return {\n          width: parseInt(match[1]),\n          height: parseInt(match[2])\n        };\n      }\n    } catch {\n      try {\n        const { stdout } = await new Deno.Command(\"xdpyinfo\").output();\n        const output = decode(stdout);\n        const match = output.match(/dimensions:\\s+(\\d+)x(\\d+)/);\n        if (match) {\n          return {\n            width: parseInt(match[1]),\n            height: parseInt(match[2])\n          };\n        }\n      } catch {}\n    }\n  }\n  \n  // Fallback\n  return { width: 1920, height: 1080 };\n}\n\n\n// Initialize docs on module load\n",
  "core/database.js": "// Database module - Cross-platform SQLite persistence\n\nimport { DatabaseSync } from \"node:sqlite\";  // Works in compiled binaries!\nimport { isDarwin, isWindows, homeDir, pathSep, os, tempDir } from \"./platform.js\";\n\n// Module configuration\nclass ModuleConfig {\n  static get dbPath() {\n    if (isDarwin) {\n      return `${homeDir()}/Library/Application Support/HLVM/HLVM.sqlite`;\n    } else if (isWindows) {\n      const appData = Deno.env.get(\"APPDATA\") || `${homeDir()}\\\\AppData\\\\Roaming`;\n      return `${appData}\\\\HLVM\\\\HLVM.sqlite`;\n    } else {\n      const xdgData = Deno.env.get(\"XDG_DATA_HOME\") || `${homeDir()}/.local/share`;\n      return `${xdgData}/HLVM/HLVM.sqlite`;\n    }\n  }\n\n  static get dbDir() {\n    const path = this.dbPath;\n    return path.substring(0, path.lastIndexOf(isWindows ? \"\\\\\" : \"/\"));\n  }\n\n  static get modulesDir() {\n    return `${this.dbDir}${pathSep}modules`;\n  }\n}\n\n// Database manager\nclass DatabaseManager {\n  constructor() {\n    this.path = ModuleConfig.dbPath;\n    this.dbDir = ModuleConfig.dbDir;\n    this.modulesDir = ModuleConfig.modulesDir;\n    this.db = null;\n    this.esbuild = null;\n  }\n\n  async init() {\n    // Ensure directories exist\n    await Deno.mkdir(this.dbDir, { recursive: true });\n    await Deno.mkdir(this.modulesDir, { recursive: true });\n\n    // Open database with WAL mode\n    this.db = new DatabaseSync(this.path);\n    this.db.exec(\"PRAGMA journal_mode=WAL\");\n\n    // Initialize schema\n    await this.initSchema();\n\n    // Try to load esbuild for bundling\n    try {\n      this.esbuild = await import(\"https://deno.land/x/esbuild@0.20.0/mod.js\");\n    } catch {\n      // esbuild not available - bundling will be disabled\n    }\n  }\n\n  async initSchema() {\n    const tableInfo = this.db.prepare(\"PRAGMA table_info(modules)\").all();\n    const hasSourceCode = tableInfo.some(col => col.name === 'source_code');\n    const hasFilePath = tableInfo.some(col => col.name === 'file_path');\n\n    if (hasSourceCode && !hasFilePath) {\n      await this.migrateFromOldSchema();\n    } else if (!hasSourceCode && !hasFilePath) {\n      this.createNewSchema();\n    }\n  }\n\n  async migrateFromOldSchema() {\n    console.log(\"Migrating HLVM database to new schema...\");\n    \n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS modules_new (\n        key TEXT PRIMARY KEY,\n        namespace TEXT NOT NULL,\n        file_path TEXT NOT NULL,\n        entry_point TEXT DEFAULT 'default',\n        metadata TEXT DEFAULT '{}',\n        type TEXT DEFAULT 'javascript',\n        updated_at INTEGER NOT NULL,\n        spotlight BOOLEAN DEFAULT 1\n      )\n    `);\n    \n    const oldModules = this.db.prepare(\"SELECT * FROM modules\").all();\n    for (const mod of oldModules) {\n      const fileName = `${mod.key}.module.js`;\n      const filePath = `${this.modulesDir}${pathSep}${fileName}`;\n      await Deno.writeTextFile(filePath, mod.source_code);\n      \n      this.db.prepare(`\n        INSERT INTO modules_new (key, namespace, file_path, entry_point, metadata, type, updated_at, spotlight)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `).run(mod.key, mod.namespace, `modules/${fileName}`, 'default', mod.metadata, mod.type, mod.updated_at, mod.spotlight);\n    }\n    \n    this.db.exec(\"DROP TABLE modules\");\n    this.db.exec(\"ALTER TABLE modules_new RENAME TO modules\");\n    console.log(\"Migration complete!\");\n  }\n\n  createNewSchema() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS modules (\n        key TEXT PRIMARY KEY,\n        namespace TEXT NOT NULL,\n        file_path TEXT NOT NULL,\n        entry_point TEXT DEFAULT 'default',\n        metadata TEXT DEFAULT '{}',\n        type TEXT DEFAULT 'javascript',\n        updated_at INTEGER NOT NULL,\n        spotlight BOOLEAN DEFAULT 1\n      )\n    `);\n  }\n}\n\n// Module bundler\nclass ModuleBundler {\n  constructor(esbuild) {\n    this.esbuild = esbuild;\n  }\n\n  async isFilePath(input) {\n    try {\n      const stat = await Deno.stat(input);\n      return stat.isFile;\n    } catch {\n      return input.includes('/') || input.endsWith('.js') || input.endsWith('.ts');\n    }\n  }\n\n  async bundle(codeOrPath) {\n    if (!this.esbuild) {\n      // Fallback without bundling\n      const isPath = await this.isFilePath(codeOrPath);\n      if (isPath) {\n        return await Deno.readTextFile(codeOrPath);\n      }\n      return typeof codeOrPath === 'function' \n        ? `export default ${codeOrPath.toString()}`\n        : codeOrPath;\n    }\n    \n    const isPath = await this.isFilePath(codeOrPath);\n    \n    try {\n      const result = await this.esbuild.build({\n        entryPoints: isPath ? [codeOrPath] : undefined,\n        stdin: !isPath ? {\n          contents: typeof codeOrPath === 'function' \n            ? `export default ${codeOrPath.toString()}`\n            : codeOrPath,\n          loader: 'js',\n          resolveDir: Deno.cwd(),\n        } : undefined,\n        bundle: true,\n        format: 'esm',\n        platform: 'browser',\n        target: 'esnext',\n        write: false,\n      });\n      \n      if (result.errors.length > 0) {\n        const error = result.errors[0];\n        throw new Error(`${error.text} at ${error.location?.file || 'input'}:${error.location?.line || 0}`);\n      }\n      \n      await this.esbuild.stop();\n      return result.outputFiles[0].text;\n    } catch (error) {\n      error.type = this.getErrorType(error.message);\n      throw error;\n    }\n  }\n\n  getErrorType(message) {\n    if (message.includes('Could not resolve')) return 'import';\n    if (message.includes('Syntax') || message.includes('Unexpected')) return 'syntax';\n    return 'bundle';\n  }\n}\n\n// Module operations\nclass ModuleOperations {\n  constructor(dbManager, bundler) {\n    this.dbManager = dbManager;\n    this.bundler = bundler;\n  }\n\n  async save(name, codeOrPath) {\n    try {\n      const bundled = await this.bundler.bundle(codeOrPath);\n      const hasDefaultFunction = this.hasDefaultExport(bundled);\n      \n      // Save file\n      const fileName = `${name}.module.js`;\n      const filePath = `${this.dbManager.modulesDir}${pathSep}${fileName}`;\n      await Deno.writeTextFile(filePath, bundled);\n      \n      // Save metadata\n      const metadata = this.createMetadata(hasDefaultFunction);\n      this.saveToDatabase(name, fileName, hasDefaultFunction, metadata);\n      \n      // Module change notification removed - no longer needed\n      return true;\n    } catch (error) {\n      await this.handleSaveError(name, error);\n      throw error;\n    }\n  }\n\n  hasDefaultExport(code) {\n    return code.includes('export default function') || \n           code.includes('export default async function');\n  }\n\n  createMetadata(hasDefaultFunction) {\n    return JSON.stringify({\n      hasDefaultFunction,\n      createdAt: new Date().toISOString(),\n      platform: os,\n      bundled: true,\n      isUserModule: true\n    });\n  }\n\n  saveToDatabase(name, fileName, hasDefaultFunction, metadata) {\n    const namespace = `hlvm.${name}`;\n    const entryPoint = hasDefaultFunction ? 'default' : 'script';\n    \n    this.dbManager.db.prepare(`\n      INSERT OR REPLACE INTO modules \n      (key, namespace, file_path, entry_point, metadata, type, updated_at, spotlight)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `).run(name, namespace, `modules/${fileName}`, entryPoint, metadata, 'javascript', Date.now(), 1);\n  }\n\n  async handleSaveError(name, error) {\n    console.error(`❌ Failed to save '${name}': ${error.message}`);\n    // Event notification removed - simplified error handling\n    console.error('Module bundle failed:', {\n      name,\n      error: error.message,\n      type: error.type || 'unknown'\n    });\n  }\n\n  async load(name) {\n    try {\n      const module = this.getModule(name);\n      if (!module) throw new Error(`Module '${name}' not found`);\n      \n      const code = await this.readModuleCode(module);\n      const imported = await this.importModule(name, code);\n      \n      return imported.default || imported;\n    } catch (e) {\n      throw new Error(`Load failed: ${e.message}`);\n    }\n  }\n\n  getModule(name) {\n    return this.dbManager.db.prepare(\"SELECT * FROM modules WHERE key = ?\").get(name);\n  }\n\n  async readModuleCode(module) {\n    const filePath = `${this.dbManager.dbDir}${pathSep}${module.file_path}`;\n    return await Deno.readTextFile(filePath);\n  }\n\n  async importModule(name, code) {\n    const tempDirectory = tempDir();\n    const tempFile = `${tempDirectory}${pathSep}hlvm-module-${name}-${Date.now()}.js`;\n    await Deno.writeTextFile(tempFile, code);\n    \n    const imported = await import(`file://${tempFile}`);\n    \n    // Clean up after import\n    setTimeout(() => Deno.remove(tempFile).catch(() => {}), 1000);\n    \n    return imported;\n  }\n\n  async getSource(name) {\n    try {\n      const module = this.getModule(name);\n      if (!module) throw new Error(`Module '${name}' not found`);\n      \n      return await this.readModuleCode(module);\n    } catch (e) {\n      throw new Error(`Get source failed: ${e.message}`);\n    }\n  }\n\n  list() {\n    try {\n      const modules = this.dbManager.db.prepare(`\n        SELECT key, namespace, file_path, entry_point, type, updated_at, spotlight \n        FROM modules \n        WHERE spotlight = 1 \n        ORDER BY updated_at DESC\n      `).all();\n      \n      return modules.map(m => ({\n        key: m.key,\n        namespace: m.namespace,\n        filePath: m.file_path,\n        entryPoint: m.entry_point,\n        type: m.type,\n        updatedAt: new Date(m.updated_at)\n      }));\n    } catch (e) {\n      return [];\n    }\n  }\n\n  async remove(name) {\n    try {\n      const module = this.getModule(name);\n      \n      if (module) {\n        const filePath = `${this.dbManager.dbDir}${pathSep}${module.file_path}`;\n        await Deno.remove(filePath).catch(() => {});\n      }\n      \n      this.dbManager.db.prepare(\"DELETE FROM modules WHERE key = ?\").run(name);\n      // Module change notification removed - no longer needed\n      \n      return true;\n    } catch (e) {\n      throw new Error(`Remove failed: ${e.message}`);\n    }\n  }\n}\n\n// Initialize and export\nconst dbManager = new DatabaseManager();\nawait dbManager.init();\n\nconst bundler = new ModuleBundler(dbManager.esbuild);\nconst operations = new ModuleOperations(dbManager, bundler);\n\n// Export public API\nexport const path = dbManager.path;\nexport const db = dbManager.db;\nexport const save = (name, codeOrPath) => operations.save(name, codeOrPath);\nexport const load = async (name) => await operations.load(name);\nexport const getSource = async (name) => await operations.getSource(name);\nexport const list = () => operations.list();\nexport const remove = (name) => operations.remove(name);",
  "core/env.js": "// HLVM Environment Settings - Persistent configuration\n// Uses existing database infrastructure\n\nimport { db } from \"./database.js\";\n\n// Settings schema with validation\nconst SCHEMA = {\n  'ai.model': {\n    type: 'string',\n    default: 'qwen2.5-coder:1.5b',\n    description: 'Default AI model for chat/revise',\n    validate: (v) => typeof v === 'string' && v.length > 0\n  },\n  'ai.temperature': {\n    type: 'number',\n    default: 0.7,\n    description: 'AI creativity (0=focused, 2=creative)',\n    validate: (v) => {\n      const num = Number(v);\n      return !isNaN(num) && num >= 0 && num <= 2;\n    },\n    parse: (v) => Number(v)\n  },\n  'ai.max_tokens': {\n    type: 'number',\n    default: 4000,\n    description: 'Max response length',\n    validate: (v) => {\n      const num = Number(v);\n      return !isNaN(num) && num > 0 && num <= 100000;\n    },\n    parse: (v) => Math.floor(Number(v))\n  },\n  'ollama.host': {\n    type: 'string',\n    default: '127.0.0.1:11434',\n    description: 'Ollama server address',\n    validate: (v) => typeof v === 'string' && v.includes(':')\n  }\n};\n\n// Create env table on module load\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS hlvm_env (\n    key TEXT PRIMARY KEY,\n    value TEXT NOT NULL,\n    updated_at INTEGER NOT NULL\n  )\n`);\n\nexport function get(key) {\n  // Only return values for known settings\n  const schema = SCHEMA[key];\n  if (!schema) {\n    return undefined; // Unknown key\n  }\n  \n  const row = db.prepare('SELECT value FROM hlvm_env WHERE key = ?').get(key);\n  if (row) {\n    // Parse value if parser exists\n    if (schema.parse) {\n      return schema.parse(row.value);\n    }\n    return row.value;\n  }\n  \n  // Return default\n  return schema.default;\n}\n\nexport function set(key, value) {\n  // Only allow known settings\n  const schema = SCHEMA[key];\n  if (!schema) {\n    // Unknown setting - silently ignore\n    return undefined;\n  }\n  \n  // Validate value\n  if (!schema.validate(value)) {\n    // Invalid value type - keep current value\n    return get(key); // Return current value\n  }\n  \n  // Parse value if needed\n  const finalValue = schema.parse ? schema.parse(value) : value;\n  \n  // Store in database\n  db.prepare(`\n    INSERT OR REPLACE INTO hlvm_env (key, value, updated_at) \n    VALUES (?, ?, ?)\n  `).run(key, String(finalValue), Date.now());\n  \n  console.log(`✓ Set ${key} = ${finalValue}`);\n  return finalValue;\n}\n\nexport function show() {\n  console.log('\\n\\x1b[36m═══ HLVM Environment Settings ═══\\x1b[0m\\n');\n  \n  // Show all settings with current values and descriptions\n  for (const [key, schema] of Object.entries(SCHEMA)) {\n    const currentValue = get(key);\n    const isCustom = has(key);\n    const status = isCustom ? '\\x1b[32m●\\x1b[0m' : '\\x1b[90m○\\x1b[0m';\n    const valueDisplay = isCustom ? `\\x1b[33m${currentValue}\\x1b[0m` : `\\x1b[90m${currentValue}\\x1b[0m`;\n    \n    console.log(`${status} ${key}: ${valueDisplay}`);\n    console.log(`  \\x1b[90m${schema.description}\\x1b[0m`);\n    if (!isCustom) {\n      console.log(`  \\x1b[90m(using default)\\x1b[0m`);\n    }\n  }\n  \n  console.log('\\n\\x1b[33mUsage:\\x1b[0m');\n  console.log('  hlvm.env.set(\"ai.model\", \"llama3.2\")   \\x1b[90m# Set value\\x1b[0m');\n  console.log('  hlvm.env.get(\"ai.model\")               \\x1b[90m# Get value\\x1b[0m');\n  console.log('  hlvm.env.reset(\"ai.model\")             \\x1b[90m# Reset to default\\x1b[0m');\n  console.log('  hlvm.env.reset()                       \\x1b[90m# Reset ALL to defaults\\x1b[0m');\n  console.log('  hlvm.env.list()                        \\x1b[90m# Get all settings\\x1b[0m');\n  console.log('  hlvm.env.show()                        \\x1b[90m# Display this help\\x1b[0m\\n');\n}\n\nexport function list() {\n  // Return all settings with current values (custom or default)\n  const result = {};\n  for (const key in SCHEMA) {\n    result[key] = get(key);\n  }\n  return result;\n}\n\nexport function reset(key) {\n  if (key) {\n    // Reset single setting to default\n    if (!SCHEMA[key]) {\n      // Unknown setting - ignore\n      return false;\n    }\n    db.prepare('DELETE FROM hlvm_env WHERE key = ?').run(key);\n    console.log(`✓ Reset ${key} to default (${SCHEMA[key].default})`);\n    return true;\n  } else {\n    // Reset ALL settings to defaults\n    db.prepare('DELETE FROM hlvm_env').run();\n    console.log('✓ Reset all settings to defaults');\n    return true;\n  }\n}\n\nexport function has(key) {\n  // Check if setting has a custom value (not using default)\n  if (!SCHEMA[key]) {\n    return false; // Unknown key\n  }\n  const row = db.prepare('SELECT 1 FROM hlvm_env WHERE key = ?').get(key);\n  return !!row;\n}\n\nexport default {\n  get,\n  set,\n  list,\n  reset,  // Reset to defaults (not remove!)\n  has,\n  show    // Extra helper for pretty display\n};",
  "core/event.js": "// HLVM Core Event System - Observe functions, properties, and files\n// Smart observation API that detects what you're trying to observe\n\n// Store all active observers\nconst observers = new Map();\nconst fileWatchers = new Map();\n\n/**\n * Observe function calls, property changes, or file modifications\n * @param {string} target - Path to observe (hlvm.*, file path, or pattern)\n * @param {Object} hooks - Observation hooks\n * @param {Function} [hooks.before] - Called before function execution\n * @param {Function} [hooks.after] - Called after function execution  \n * @param {Function} [hooks.error] - Called on function error\n * @param {Function} [hooks.onChange] - Called on property/file change\n * @returns {boolean} True if observer was added successfully\n * @example\n * // Observe function calls\n * hlvm.core.event.observe('hlvm.core.io.fs.write', {\n *   before: (args) => console.log('Writing:', args[0]),\n *   after: (result) => console.log('Wrote successfully')\n * })\n * @example\n * // Observe file changes\n * hlvm.core.event.observe('/tmp/watch.txt', {\n *   onChange: (event) => console.log('File changed:', event.kind)\n * })\n * @example  \n * // Observe pattern (all fs functions)\n * hlvm.core.event.observe('hlvm.core.io.fs.*', {\n *   before: (args, path) => console.log(`Calling ${path}:`, args)\n * })\n */\nexport function observe(target, hooks) {\n  if (typeof target !== 'string') {\n    throw new Error('Target must be a string path');\n  }\n  \n  // Detect what type of target this is\n  if (isFilePath(target)) {\n    return observeFile(target, hooks);\n  }\n  \n  if (target.includes('*')) {\n    return observePattern(target, hooks);\n  }\n  \n  if (target.startsWith('hlvm.')) {\n    return observeHlvmPath(target, hooks);\n  }\n  \n  throw new Error(`Cannot observe: ${target}`);\n}\n\n/**\n * Stop observing a target or all targets\n * @param {string} [target] - Path to stop observing. If omitted, removes ALL observers\n * @returns {number|boolean} Count of removed observers (if no target) or success boolean\n * @example\n * // Remove specific observer\n * hlvm.core.event.unobserve('hlvm.core.io.fs.write')\n * @example\n * // Remove all observers\n * const count = hlvm.core.event.unobserve()\n * console.log(`Removed ${count} observers`)\n */\nexport function unobserve(target) {\n  // If no target, remove ALL observers\n  if (target === undefined) {\n    let count = 0;\n    \n    // Remove all function/property observers\n    for (const [path] of observers) {\n      if (unobserve(path)) count++;\n    }\n    \n    // Remove all file watchers\n    for (const [path] of fileWatchers) {\n      if (unobserve(path)) count++;\n    }\n    \n    return count;\n  }\n  \n  // Remove specific observer\n  if (observers.has(target)) {\n    const observer = observers.get(target);\n    \n    // Restore original function if it was wrapped\n    if (observer.type === 'function' && observer.original) {\n      const parts = target.split('.');\n      let obj = globalThis;\n      \n      for (let i = 0; i < parts.length - 1; i++) {\n        obj = obj[parts[i]];\n      }\n      \n      obj[parts[parts.length - 1]] = observer.original;\n    }\n    \n    // Remove property descriptor if it was modified\n    if (observer.type === 'property' && observer.descriptor) {\n      const parts = target.split('.');\n      let obj = globalThis;\n      \n      for (let i = 0; i < parts.length - 1; i++) {\n        obj = obj[parts[i]];\n      }\n      \n      Object.defineProperty(obj, parts[parts.length - 1], observer.descriptor);\n    }\n    \n    observers.delete(target);\n    return true;\n  }\n  \n  // Remove file watcher\n  if (fileWatchers.has(target)) {\n    const { watcher, abortController } = fileWatchers.get(target);\n    abortController.abort(); // Signal the watching loop to stop\n    watcher.close(); // Close the watcher\n    fileWatchers.delete(target);\n    return true;\n  }\n  \n  // Remove pattern observers\n  if (target.includes('*')) {\n    let removed = false;\n    for (const [key, observer] of observers) {\n      if (observer.pattern === target) {\n        unobserve(key);\n        removed = true;\n      }\n    }\n    return removed;\n  }\n  \n  return false;\n}\n\n// Helper: Check if string is a file path\nfunction isFilePath(str) {\n  return str.startsWith('/') || \n         str.startsWith('./') || \n         str.startsWith('../') ||\n         str.startsWith('~') ||\n         (str.includes('.') && !str.startsWith('hlvm.'));\n}\n\n// Helper: Observe a file for changes\nfunction observeFile(path, hooks) {\n  if (!hooks.onChange) {\n    throw new Error('File observation requires onChange hook');\n  }\n  \n  // Use Deno.watchFs for file watching\n  const watcher = Deno.watchFs(path);\n  \n  // Create abort controller for cleanup\n  const abortController = new AbortController();\n  \n  // Store watcher with abort controller for cleanup\n  fileWatchers.set(path, { watcher, abortController });\n  \n  // Start watching in background with proper cleanup\n  (async () => {\n    try {\n      for await (const event of watcher) {\n        // Check if we should stop watching\n        if (abortController.signal.aborted) break;\n        \n        if (event.kind === 'modify' || event.kind === 'create') {\n          await hooks.onChange(event, path);\n        }\n      }\n    } catch (error) {\n      // Ignore errors from closing the watcher\n      if (!abortController.signal.aborted && hooks.error) {\n        await hooks.error(error, path);\n      }\n    }\n  })();\n  \n  return true;\n}\n\n// Helper: Observe pattern (e.g., hlvm.core.io.fs.*)\nfunction observePattern(pattern, hooks) {\n  const base = pattern.replace('*', '');\n  \n  // Find all matching functions\n  const parts = base.split('.');\n  let obj = globalThis;\n  \n  for (const part of parts) {\n    if (part) {\n      obj = obj[part];\n      if (!obj) return false;\n    }\n  }\n  \n  // Wrap all functions in the object\n  let count = 0;\n  for (const key in obj) {\n    if (typeof obj[key] === 'function') {\n      const fullPath = base + key;\n      observeHlvmPath(fullPath, hooks);\n      count++;\n    }\n  }\n  \n  return count > 0;\n}\n\n// Helper: Observe HLVM path (function or property)\nfunction observeHlvmPath(path, hooks) {\n  const parts = path.split('.');\n  let obj = globalThis;\n  \n  // Navigate to parent object\n  for (let i = 0; i < parts.length - 1; i++) {\n    obj = obj[parts[i]];\n    if (!obj) {\n      throw new Error(`Path not found: ${path}`);\n    }\n  }\n  \n  const propName = parts[parts.length - 1];\n  const value = obj[propName];\n  \n  // Check if it's a function\n  if (typeof value === 'function') {\n    return observeFunction(obj, propName, path, hooks);\n  } else {\n    return observeProperty(obj, propName, path, hooks);\n  }\n}\n\n// Helper: Observe a function\nfunction observeFunction(obj, propName, path, hooks) {\n  const original = obj[propName];\n  \n  // Store original for restoration\n  observers.set(path, {\n    type: 'function',\n    original: original,\n    hooks: hooks\n  });\n  \n  // Create wrapper function\n  obj[propName] = async function(...args) {\n    let modifiedArgs = args;\n    \n    // Call before hook\n    if (hooks.before) {\n      const result = await hooks.before(args, path);\n      if (result !== undefined) {\n        modifiedArgs = Array.isArray(result) ? result : [result];\n      }\n    }\n    \n    try {\n      // Call original function\n      const result = await original.apply(this, modifiedArgs);\n      \n      // Call after hook\n      if (hooks.after) {\n        await hooks.after(result, modifiedArgs, path);\n      }\n      \n      return result;\n    } catch (error) {\n      // Call error hook\n      if (hooks.error) {\n        await hooks.error(error, modifiedArgs, path);\n      }\n      throw error;\n    }\n  };\n  \n  // Preserve function name and properties\n  Object.defineProperty(obj[propName], 'name', { value: original.name });\n  Object.setPrototypeOf(obj[propName], original);\n  \n  return true;\n}\n\n// Helper: Observe a property\nfunction observeProperty(obj, propName, path, hooks) {\n  if (!hooks.onChange) {\n    throw new Error('Property observation requires onChange hook');\n  }\n  \n  const descriptor = Object.getOwnPropertyDescriptor(obj, propName);\n  let currentValue = obj[propName];\n  \n  // Store original descriptor for restoration\n  observers.set(path, {\n    type: 'property',\n    descriptor: descriptor,\n    hooks: hooks\n  });\n  \n  // Define new property with getter/setter\n  Object.defineProperty(obj, propName, {\n    get() {\n      return currentValue;\n    },\n    set(newValue) {\n      const oldValue = currentValue;\n      \n      // Call onChange hook\n      const result = hooks.onChange(newValue, oldValue, path);\n      \n      // Allow hook to modify or reject the value\n      if (result !== undefined) {\n        newValue = result;\n      }\n      \n      currentValue = newValue;\n      return true;\n    },\n    enumerable: descriptor ? descriptor.enumerable : true,\n    configurable: true\n  });\n  \n  return true;\n}\n\n/**\n * List all active observers\n * @returns {Array<{path: string, type: string, hooks: string[]}>} Array of observer info\n * @example\n * const observers = hlvm.core.event.list()\n * observers.forEach(o => console.log(`${o.path} (${o.type}): ${o.hooks.join(', ')}`)) \n */\nexport function list() {\n  const result = [];\n  \n  // Add function/property observers\n  for (const [path, observer] of observers) {\n    result.push({\n      path: path,\n      type: observer.type,\n      hooks: Object.keys(observer.hooks)\n    });\n  }\n  \n  // Add file watchers\n  for (const [path] of fileWatchers) {\n    result.push({\n      path: path,\n      type: 'file',\n      hooks: ['onChange']\n    });\n  }\n  \n  return result;\n}\n\n\n",
  "core/platform.js": "// Platform module - Cross-platform OS information\n\nexport const os = Deno.build.os;\nexport const arch = Deno.build.arch;\nexport const version = Deno.osRelease();\nexport const isDarwin = os === \"darwin\";\nexport const isWindows = os === \"windows\";\nexport const isLinux = os === \"linux\";\nexport function tempDir() {\n  const envTemp = Deno.env.get(\"TMPDIR\") || \n                  Deno.env.get(\"TEMP\") || \n                  Deno.env.get(\"TMP\");\n  if (envTemp) return envTemp;\n  \n  if (isWindows) {\n    const userProfile = Deno.env.get(\"USERPROFILE\");\n    if (userProfile) {\n      return `${userProfile}\\\\AppData\\\\Local\\\\Temp`;\n    }\n    return \"C:\\\\Windows\\\\Temp\";\n  }\n  \n  return \"/tmp\";\n}\n\nexport function homeDir() {\n  if (isWindows) {\n    return Deno.env.get(\"USERPROFILE\") || Deno.env.get(\"HOMEDRIVE\") + Deno.env.get(\"HOMEPATH\");\n  }\n  return Deno.env.get(\"HOME\") || \"/\";\n}\n\n// Path and executable info\nexport const pathSep = isWindows ? \"\\\\\" : \"/\";\nexport const exeExt = isWindows ? \".exe\" : \"\";\n\n// Shell access\nexport function shell() {\n  if (isWindows) {\n    return [\"cmd\", \"/c\"];\n  }\n  return [\"sh\", \"-c\"];\n}\n\n// ===== MERGED FROM utils.js =====\n\n// Escape string for shell command (cross-platform)\nexport function escapeShell(str) {\n  if (isWindows) {\n    // PowerShell escaping\n    return str.replace(/\"/g, '`\"').replace(/\\$/g, '`$');\n  } else {\n    // Unix shell escaping\n    return str.replace(/'/g, \"'\\\\''\");\n  }\n}\n\n// Escape text for keyboard input (cross-platform)\nexport function escapeKeyboard(text) {\n  if (isWindows) {\n    // PowerShell SendKeys escaping\n    return text\n      .replace(/\\{/g, '{{')\n      .replace(/\\}/g, '}}')\n      .replace(/\\(/g, '{(}')\n      .replace(/\\)/g, '{)}')\n      .replace(/\\+/g, '{+}')\n      .replace(/\\^/g, '{^}')\n      .replace(/%/g, '{%}')\n      .replace(/~/g, '{~}');\n  } else {\n    // Unix shell escaping for osascript\n    return text.replace(/'/g, \"'\\\\''\");\n  }\n}\n\n// ===== MERGED FROM exec.js =====\n\n// Decode text from command output\nexport function decode(buffer) {\n  return new TextDecoder().decode(buffer);\n}\n\n// Run PowerShell command with standard args\nexport async function powershell(script) {\n  return await new Deno.Command(\"powershell\", {\n    args: [\"-NoProfile\", \"-Command\", script]\n  }).output();\n}\n\n// PowerShell script boilerplate\nexport const PS = {\n  forms: \"Add-Type -AssemblyName System.Windows.Forms\",\n  drawing: \"Add-Type -AssemblyName System.Drawing\",\n  visualBasic: \"Add-Type -AssemblyName Microsoft.VisualBasic\"\n};\n\n// Linux tool with xdotool/ydotool fallback\nexport async function linuxTool(xdotoolArgs, ydotoolArgs, errorMsg) {\n  try {\n    return await new Deno.Command(\"xdotool\", { args: xdotoolArgs }).output();\n  } catch {\n    try {\n      return await new Deno.Command(\"ydotool\", { args: ydotoolArgs }).output();\n    } catch {\n      throw new Error(errorMsg || \"Install xdotool (X11) or ydotool (Wayland)\");\n    }\n  }\n}\n\n// Common error messages\nexport const ERRORS = {\n  LINUX_TOOLS: \"Install xdotool (X11) or ydotool (Wayland)\",\n  LINUX_NOTIFY: \"Install libnotify-bin (notify-send)\",\n  LINUX_DIALOG: \"Install zenity or kdialog\"\n};",
  "core/system.js": "// System module - Cross-platform system utilities\n\nimport { shell, decode } from \"./platform.js\";\n\nexport async function hostname() {\n  try {\n    return Deno.hostname();\n  } catch {\n    const p = new Deno.Command(\"hostname\");\n    const { stdout } = await p.output();\n    return decode(stdout).trim();\n  }\n}\n\nexport async function exec(cmd) {\n  const shellCmd = shell();\n  const p = new Deno.Command(shellCmd[0], { \n    args: [...shellCmd.slice(1), cmd] \n  });\n  const { stdout, stderr, code } = await p.output();\n  return {\n    stdout: decode(stdout),\n    stderr: decode(stderr),\n    code\n  };\n}\n\n// Direct exports from Deno\nexport const exit = Deno.exit;\nexport const pid = () => Deno.pid;\nexport const cwd = Deno.cwd;\nexport const chdir = Deno.chdir;\n\nexport function env(key, value) {\n  if (value !== undefined) {\n    Deno.env.set(key, value);\n  }\n  return Deno.env.get(key);\n}",
  "core/utils.js": "// Core utilities for DRY principles across stdlib\nimport { isDarwin, isWindows, decode } from \"./platform.js\";\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Platform-specific command execution with fallback support\n\n/**\n * Execute platform-specific commands with automatic OS detection\n * @param {Object} commands - Platform-specific command configurations\n * @param {Object} commands.darwin - macOS command config {cmd, args}\n * @param {Object} commands.windows - Windows command config {cmd, args} or {script} for PowerShell\n * @param {Array|Object} commands.linux - Linux command(s) - can be array for fallback tools\n * @returns {Promise<Object>} Command result with {success, stdout, stderr, code}\n */\nexport async function platformCommand(commands) {\n  if (isDarwin && commands.darwin) {\n    return await runCommand(commands.darwin);\n  }\n  \n  if (isWindows && commands.windows) {\n    if (commands.windows.script) {\n      // PowerShell script execution\n      return await runPowerShell(commands.windows.script);\n    }\n    return await runCommand(commands.windows);\n  }\n  \n  if (commands.linux) {\n    // Linux with fallback support for multiple tools\n    const tools = Array.isArray(commands.linux) ? commands.linux : [commands.linux];\n    return await runWithFallback(tools);\n  }\n  \n  throw new Error(`Unsupported platform: ${Deno.build.os}`);\n}\n\n/**\n * Run a single command\n */\nasync function runCommand(config) {\n  const { cmd, args = [] } = config;\n  const command = new Deno.Command(cmd, { args });\n  const result = await command.output();\n  return {\n    success: result.success,\n    stdout: decode(result.stdout),\n    stderr: decode(result.stderr),\n    code: result.code\n  };\n}\n\n/**\n * Run PowerShell script on Windows\n */\nasync function runPowerShell(script) {\n  return await runCommand({\n    cmd: \"powershell\",\n    args: [\"-NoProfile\", \"-Command\", script]\n  });\n}\n\n/**\n * Try multiple Linux tools until one succeeds\n */\nasync function runWithFallback(tools) {\n  let lastError = null;\n  \n  for (const tool of tools) {\n    try {\n      const result = await runCommand(tool);\n      if (result.success) {\n        return result;\n      }\n      lastError = result;\n    } catch (e) {\n      lastError = { success: false, stderr: e.message };\n    }\n  }\n  \n  // All tools failed\n  const toolNames = tools.map(t => t.cmd).join(\", \");\n  throw new Error(`All tools failed. Install one of: ${toolNames}`);\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Common error handling\n\n/**\n * Check command result and throw standardized error if failed\n */\nexport function checkSuccess(result, operation = \"Operation\") {\n  if (!result.success) {\n    const error = result.stderr || `${operation} failed with code ${result.code}`;\n    throw new Error(error);\n  }\n  return result;\n}\n\n/**\n * Handle macOS permission errors with helpful guidance\n */\nexport function handleMacOSPermission(error) {\n  if (!isDarwin) return false;\n  \n  const permissionPatterns = [\n    /Operation not permitted/i,\n    /not allowed to send Apple events/i,\n    /Automation.*not allowed/i,\n    /accessibility/i\n  ];\n  \n  const message = error.message || error.stderr || String(error);\n  if (permissionPatterns.some(pattern => pattern.test(message))) {\n    console.log('\\n🔐 macOS blocked this action. Grant permission in:');\n    console.log('   System Settings → Privacy & Security → Accessibility/Automation');\n    console.log('   Quick open: open \"x-apple.systempreferences:com.apple.preference.security?Privacy\"');\n    return true;\n  }\n  return false;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// PowerShell script templates for Windows\n\nexport const PowerShellTemplates = {\n  addWindowsTypes: `\n    Add-Type -AssemblyName System.Windows.Forms\n    Add-Type -AssemblyName System.Drawing\n  `,\n  \n  getScreen: `\n    $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n    $bounds = $screen.Bounds\n  `,\n  \n  getCursorPosition: `\n    Add-Type -AssemblyName System.Windows.Forms\n    $pos = [System.Windows.Forms.Cursor]::Position\n    Write-Host \"$($pos.X),$($pos.Y)\"\n  `,\n  \n  setCursorPosition: (x, y) => `\n    Add-Type -AssemblyName System.Windows.Forms\n    [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${x}, ${y})\n  `,\n  \n  mouseClick: (button = 'left') => `\n    Add-Type @\"\n      using System;\n      using System.Runtime.InteropServices;\n      public class Mouse {\n        [DllImport(\"user32.dll\")]\n        public static extern void mouse_event(uint flags, uint x, uint y, uint data, int extraInfo);\n      }\n    \"@\n    ${button === 'right' ? \n      '[Mouse]::mouse_event(0x08, 0, 0, 0, 0); [Mouse]::mouse_event(0x10, 0, 0, 0, 0)' :\n      '[Mouse]::mouse_event(0x02, 0, 0, 0, 0); [Mouse]::mouse_event(0x04, 0, 0, 0, 0)'\n    }\n  `,\n  \n  sendKeys: (keys) => `\n    Add-Type -AssemblyName System.Windows.Forms\n    [System.Windows.Forms.SendKeys]::SendWait(\"${keys.replace(/\"/g, '\"\"')}\")\n  `,\n  \n  screenshot: (output) => `\n    Add-Type -AssemblyName System.Windows.Forms\n    Add-Type -AssemblyName System.Drawing\n    \n    $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n    $bounds = $screen.Bounds\n    $bitmap = New-Object System.Drawing.Bitmap($bounds.Width, $bounds.Height)\n    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n    $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)\n    $bitmap.Save(\"${output.replace(/\\\\/g, '\\\\\\\\')}\")\n    $graphics.Dispose()\n    $bitmap.Dispose()\n  `,\n  \n  getClipboard: `\n    Add-Type -AssemblyName System.Windows.Forms\n    [System.Windows.Forms.Clipboard]::GetText()\n  `,\n  \n  setClipboard: (text) => `\n    Add-Type -AssemblyName System.Windows.Forms\n    [System.Windows.Forms.Clipboard]::SetText(\"${text.replace(/\"/g, '\"\"')}\")\n  `\n};\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Documentation helper for consistent module initialization\n\n/**\n * Initialize function documentation for REPL discovery\n * @param {Object} functions - Object containing functions to document\n * @param {Object} docs - Documentation strings keyed by function name\n */\nexport function initializeDocs(functions, docs) {\n  const inspectSymbol = Symbol.for('Deno.customInspect');\n  \n  for (const [name, fn] of Object.entries(functions)) {\n    if (docs[name]) {\n      fn.__doc__ = docs[name];\n      fn[inspectSymbol] = function() { return this.__doc__; };\n    }\n  }\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Common input validation\n\n/**\n * Get input with clipboard fallback\n */\nexport async function getInputWithFallback(input) {\n  if (input !== undefined) return input;\n  // Dynamic import to avoid circular dependency\n  const clipboard = await globalThis.hlvm?.core?.io?.clipboard;\n  return clipboard ? await clipboard.read() : null;\n}\n\n/**\n * Validate required input\n */\nexport function validateInput(input, errorMessage = \"No input provided\") {\n  if (!input || (typeof input === 'string' && !input.trim())) {\n    throw new Error(errorMessage);\n  }\n  return input;\n}\n\nexport default {\n  platformCommand,\n  checkSuccess,\n  handleMacOSPermission,\n  PowerShellTemplates,\n  initializeDocs,\n  getInputWithFallback,\n  validateInput\n};",
  "documentation.js": "// HLVM Documentation Registry - Simple hardcoded documentation strings\n\nconst docs = new Map();\n\n// ===== AI Module Documentation =====\n\ndocs.set('hlvm.stdlib.ai.revise', `\\x1b[36mrevise(input?, options?)\\x1b[0m\n\nRevises text using AI to improve clarity, grammar, and tone\n\n\\x1b[33mParameters:\\x1b[0m\n  input: \\x1b[90mstring\\x1b[0m (optional) - Text to revise (uses clipboard if empty)\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    tone: 'default'|'professional'|'casual'|'friendly'|'concise'|'formal'\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - Revised text\n\n\\x1b[33mExamples:\\x1b[0m\n  await revise(\"thx for ur help\")\n  \\x1b[32m// → \"Thank you for your help\"\\x1b[0m\n  \n  await revise(\"hey can u send the files\", {tone: \"professional\"})\n  \\x1b[32m// → \"Could you please send the files?\"\\x1b[0m\n  \n  await revise() // Revises clipboard content\n  \\x1b[32m// → [Revised text from clipboard]\\x1b[0m`);\n\ndocs.set('hlvm.stdlib.ai.draw', `\\x1b[36mdraw(input?, options?)\\x1b[0m\n\nCreates ASCII diagrams from text using AI\n\n\\x1b[33mParameters:\\x1b[0m\n  input: \\x1b[90mstring\\x1b[0m (optional) - Text to visualize (uses clipboard if empty)\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    type: 'auto'|'flowchart'|'sequence'|'tree'|'graph'|'mindmap'|'table'\n    style: 'simple'|'detailed'\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - ASCII diagram\n\n\\x1b[33mExamples:\\x1b[0m\n  await draw(\"login -> validate -> dashboard\")\n  \\x1b[32m// → ┌─────┐    ┌──────────┐    ┌───────────┐\n  //   │login│───▶│ validate │───▶│ dashboard │\n  //   └─────┘    └──────────┘    └───────────┘\\x1b[0m\n  \n  await draw(\"user story steps\", {type: \"sequence\"})\n  \\x1b[32m// → User     System     Database\n  //   │         │           │\n  //   │─login──▶│           │\n  //   │         │──query───▶│\n  //   │         │◀──result──│\\x1b[0m`);\n\ndocs.set('hlvm.stdlib.ai.refactor', `\\x1b[36mrefactor(input?, options?)\\x1b[0m\n\nRefactors code using AI to improve quality and apply best practices\n\n\\x1b[33mParameters:\\x1b[0m\n  input: \\x1b[90mstring\\x1b[0m (optional) - Code to refactor (uses clipboard if empty)\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    type: 'all'|'clean'|'solid'|'dry'|'unused'|'simplify'|'modern'|'performance'\n\n\\x1b[33mTypes:\\x1b[0m\n  all        - Comprehensive refactor (default)\n  clean      - Clean Code principles\n  solid      - SOLID principles\n  dry        - Remove redundancy\n  unused     - Remove unused code\n  simplify   - Make code simpler\n  modern     - Update to modern syntax\n  performance - Optimize performance\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - Refactored code\n\n\\x1b[33mExamples:\\x1b[0m\n  await refactor(uglyCode)\n  \\x1b[32m// → [Clean, well-structured code]\\x1b[0m\n  \n  await refactor(code, {type: \"unused\"})\n  \\x1b[32m// → [Code with unused elements removed]\\x1b[0m`);\n\ndocs.set('hlvm.stdlib.ai.ask', `\\x1b[36mask(input?, options?)\\x1b[0m\n\nSimple chat with AI - ask any question and get an answer\n\n\\x1b[33mParameters:\\x1b[0m\n  input: \\x1b[90mstring\\x1b[0m (optional) - Question to ask (uses clipboard if empty)\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    model: Model to use\n    stream: Stream response (default: true)\n    temperature: Creativity 0-2 (default: 0.7)\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - AI response\n\n\\x1b[33mExamples:\\x1b[0m\n  await ask(\"What is the capital of France?\")\n  \\x1b[32m// → \"The capital of France is Paris.\"\\x1b[0m\n  \n  await ask(\"Explain quantum computing\")\n  \\x1b[32m// → [Detailed explanation...]\\x1b[0m`);\n\n// ===== File System Documentation =====\n\ndocs.set('hlvm.core.io.fs.read', `\\x1b[36mread(path)\\x1b[0m\n\nReads text content from a file\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m - File path to read\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - File content\n\n\\x1b[33mExample:\\x1b[0m\n  await read('/tmp/test.txt')\n  \\x1b[32m// → \"Hello World\"\\x1b[0m`);\n\ndocs.set('hlvm.core.io.fs.write', `\\x1b[36mwrite(path, content)\\x1b[0m\n\nWrites text content to a file\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m - File path\n  content: \\x1b[90mstring\\x1b[0m - Text to write\n\n\\x1b[33mReturns:\\x1b[0m Promise<void>\n\n\\x1b[33mExample:\\x1b[0m\n  await write('/tmp/test.txt', 'Hello')\n  \\x1b[32m// → File created\\x1b[0m`);\n\ndocs.set('hlvm.core.io.fs.exists', `\\x1b[36mexists(path)\\x1b[0m\n\nChecks if file or directory exists\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m - Path to check\n\n\\x1b[33mReturns:\\x1b[0m Promise<boolean>\n\n\\x1b[33mExample:\\x1b[0m\n  await exists('/tmp/test.txt')\n  \\x1b[32m// → true\\x1b[0m`);\n\ndocs.set('hlvm.core.io.fs.mkdir', `\\x1b[36mmkdir(path, options?)\\x1b[0m\n\nCreates a directory\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m - Directory path\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    recursive: Create parent dirs\n\n\\x1b[33mExample:\\x1b[0m\n  await mkdir('/tmp/test/deep')\n  \\x1b[32m// → Directory created\\x1b[0m`);\n\ndocs.set('hlvm.core.io.fs.remove', `\\x1b[36mremove(path, options?)\\x1b[0m\n\nRemoves file or directory\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m - Path to remove\n  options: \\x1b[90mObject\\x1b[0m (optional)\n    recursive: Remove contents\n\n\\x1b[33mExample:\\x1b[0m\n  await remove('/tmp/test')\n  \\x1b[32m// → Removed\\x1b[0m`);\n\n// ===== Clipboard Documentation =====\n\ndocs.set('hlvm.core.io.clipboard.read', `\\x1b[36mread()\\x1b[0m\n\nReads text from system clipboard\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - Clipboard content\n\n\\x1b[33mExample:\\x1b[0m\n  await clipboard.read()\n  \\x1b[32m// → \"copied text\"\\x1b[0m`);\n\ndocs.set('hlvm.core.io.clipboard.write', `\\x1b[36mwrite(text)\\x1b[0m\n\nWrites text to system clipboard\n\n\\x1b[33mParameters:\\x1b[0m\n  text: \\x1b[90mstring\\x1b[0m - Text to copy\n\n\\x1b[33mExample:\\x1b[0m\n  await clipboard.write(\"Hello\")\n  \\x1b[32m// → Copied to clipboard\\x1b[0m`);\n\n// ===== Keyboard Documentation =====\n\ndocs.set('hlvm.core.computer.keyboard.type', `\\x1b[36mtype(text)\\x1b[0m\n\nTypes text as if typed on keyboard\n\n\\x1b[33mParameters:\\x1b[0m\n  text: \\x1b[90mstring\\x1b[0m - Text to type\n\n\\x1b[33mExample:\\x1b[0m\n  await keyboard.type(\"Hello\")\n  \\x1b[32m// → Types each character\\x1b[0m`);\n\ndocs.set('hlvm.core.computer.keyboard.press', `\\x1b[36mpress(keys)\\x1b[0m\n\nPresses keyboard shortcut\n\n\\x1b[33mParameters:\\x1b[0m\n  keys: \\x1b[90mstring | string[]\\x1b[0m - Key(s) to press\n\n\\x1b[33mExamples:\\x1b[0m\n  await keyboard.press(\"enter\")\n  \\x1b[32m// → Presses Enter\\x1b[0m\n  \n  await keyboard.press([\"cmd\", \"s\"])\n  \\x1b[32m// → Presses Cmd+S\\x1b[0m`);\n\n// ===== Mouse Documentation =====\n\ndocs.set('hlvm.core.computer.mouse.click', `\\x1b[36mclick(x?, y?, button?)\\x1b[0m\n\nClicks mouse at position\n\n\\x1b[33mParameters:\\x1b[0m\n  x: \\x1b[90mnumber\\x1b[0m (optional) - X coordinate\n  y: \\x1b[90mnumber\\x1b[0m (optional) - Y coordinate\n  button: \\x1b[90mstring\\x1b[0m (optional) - 'left'|'right'\n\n\\x1b[33mExample:\\x1b[0m\n  await mouse.click(100, 200)\n  \\x1b[32m// → Clicks at (100, 200)\\x1b[0m`);\n\ndocs.set('hlvm.core.computer.mouse.move', `\\x1b[36mmove(x, y)\\x1b[0m\n\nMoves mouse to position\n\n\\x1b[33mParameters:\\x1b[0m\n  x: \\x1b[90mnumber\\x1b[0m - X coordinate\n  y: \\x1b[90mnumber\\x1b[0m - Y coordinate\n\n\\x1b[33mExample:\\x1b[0m\n  await mouse.move(500, 300)\n  \\x1b[32m// → Moves to (500, 300)\\x1b[0m`);\n\n// ===== Screen Documentation =====\n\ndocs.set('hlvm.core.computer.screen.capture', `\\x1b[36mcapture(path?)\\x1b[0m\n\nCaptures screenshot\n\n\\x1b[33mParameters:\\x1b[0m\n  path: \\x1b[90mstring\\x1b[0m (optional) - Save path\n\n\\x1b[33mReturns:\\x1b[0m Promise<string> - Screenshot path\n\n\\x1b[33mExample:\\x1b[0m\n  await screen.capture(\"/tmp/shot.png\")\n  \\x1b[32m// → \"/tmp/shot.png\"\\x1b[0m`);\n\n// ===== Notification Documentation =====\n\ndocs.set('hlvm.core.ui.notification.notify', `\\x1b[36mnotify(message, title?)\\x1b[0m\n\nShows system notification\n\n\\x1b[33mParameters:\\x1b[0m\n  message: \\x1b[90mstring\\x1b[0m - Message text\n  title: \\x1b[90mstring\\x1b[0m (optional) - Title\n\n\\x1b[33mExample:\\x1b[0m\n  await notify(\"Task done!\", \"HLVM\")\n  \\x1b[32m// → Shows notification\\x1b[0m`);\n\n// ===== Event System Documentation =====\n\ndocs.set('hlvm.core.event.observe', `\\x1b[36mobserve(target, hooks)\\x1b[0m\n\nObserve function calls or file changes\n\n\\x1b[33mParameters:\\x1b[0m\n  target: \\x1b[90mstring\\x1b[0m - Path to observe\n  hooks: \\x1b[90mObject\\x1b[0m - Event hooks\n    before: Before function call\n    after: After function call\n    onChange: On file change\n\n\\x1b[33mExample:\\x1b[0m\n  observe('hlvm.core.io.fs.write', {\n    before: (args) => console.log('Writing:', args[0])\n  })`);\n\n// Export the documentation map\nexport default docs;",
  "fs/filesystem.js": "// Filesystem module - Cross-platform file operations\n\nimport { pathSep } from \"../core/platform.js\";\n\n// File operations\nclass FileOps {\n  /**\n   * Reads text content from a file\n   * @param {string} path - File path to read\n   * @returns {Promise<string>} File content as text\n   * @example\n   * await read('/tmp/test.txt')\n   * // → \"Hello World\"\n   */\n  static read = (path) => Deno.readTextFile(path);\n  /**\n   * Writes text content to a file\n   * @param {string} path - File path to write\n   * @param {string} content - Text content to write\n   * @returns {Promise<void>}\n   * @example\n   * await write('/tmp/test.txt', 'Hello World')\n   * // → File created with content\n   */\n  static write = (path, content) => Deno.writeTextFile(path, content);\n  /**\n   * Reads binary content from a file\n   * @param {string} path - File path to read\n   * @returns {Promise<Uint8Array>} File content as bytes\n   * @example\n   * await readBytes('/tmp/image.png')\n   * // → Uint8Array[137, 80, 78, ...]\n   */\n  static readBytes = (path) => Deno.readFile(path);\n  /**\n   * Writes binary content to a file\n   * @param {string} path - File path to write\n   * @param {Uint8Array} data - Binary data to write\n   * @returns {Promise<void>}\n   * @example\n   * await writeBytes('/tmp/data.bin', new Uint8Array([1,2,3]))\n   * // → Binary file created\n   */\n  static writeBytes = (path, data) => Deno.writeFile(path, data);\n  \n  /**\n   * Checks if a file or directory exists\n   * @param {string} path - Path to check\n   * @returns {Promise<boolean>} True if exists\n   * @example\n   * await exists('/tmp/test.txt')\n   * // → true\n   */\n  static async exists(path) {\n    try {\n      await Deno.stat(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * Gets file or directory information\n   * @param {string} path - Path to stat\n   * @returns {Promise<Deno.FileInfo>} File information\n   * @example\n   * await stat('/tmp/test.txt')\n   * // → {size: 11, isFile: true, isDirectory: false, ...}\n   */\n  static stat = (path) => Deno.stat(path);\n}\n\n// Directory operations\nclass DirOps {\n  /**\n   * Creates a directory\n   * @param {string} path - Directory path to create\n   * @param {Object} [options={recursive: true}] - Creation options\n   * @returns {Promise<void>}\n   * @example\n   * await mkdir('/tmp/test/deep/path')\n   * // → Creates all directories in path\n   */\n  static mkdir = (path, options = { recursive: true }) => Deno.mkdir(path, options);\n  /**\n   * Reads directory contents\n   * @param {string} path - Directory path to read\n   * @returns {AsyncIterable<Deno.DirEntry>} Directory entries\n   * @example\n   * for await (const entry of readdir('/tmp')) {\n   *   console.log(entry.name, entry.isFile)\n   * }\n   * // → test.txt true\n   * // → subdir false\n   */\n  static readdir = (path) => Deno.readDir(path);\n  /**\n   * Removes a file or directory\n   * @param {string} path - Path to remove\n   * @param {Object} [options={recursive: true}] - Removal options\n   * @returns {Promise<void>}\n   * @example\n   * await remove('/tmp/test')\n   * // → Removes test and all contents\n   */\n  static remove = (path, options = { recursive: true }) => Deno.remove(path, options);\n  \n  /**\n   * Copies files or directories recursively\n   * @param {string} src - Source path\n   * @param {string} dest - Destination path\n   * @returns {Promise<void>}\n   * @example\n   * await copy('/tmp/source', '/tmp/backup')\n   * // → Creates backup with all contents\n   */\n  static async copy(src, dest) {\n    const srcStat = await FileOps.stat(src);\n    \n    if (srcStat.isFile) {\n      const data = await FileOps.readBytes(src);\n      await FileOps.writeBytes(dest, data);\n    } else if (srcStat.isDirectory) {\n      await this.mkdir(dest);\n      for await (const entry of this.readdir(src)) {\n        await this.copy(\n          PathUtils.join(src, entry.name),\n          PathUtils.join(dest, entry.name)\n        );\n      }\n    }\n  }\n  \n  /**\n   * Moves or renames files and directories\n   * @param {string} src - Source path\n   * @param {string} dest - Destination path\n   * @returns {Promise<void>}\n   * @example\n   * await move('/tmp/old.txt', '/tmp/new.txt')\n   * // → Renames old.txt to new.txt\n   */\n  static async move(src, dest) {\n    try {\n      await Deno.rename(src, dest);\n    } catch {\n      // If rename fails (e.g., across drives on Windows), copy and delete\n      await this.copy(src, dest);\n      await this.remove(src);\n    }\n  }\n}\n\n// Path utilities\nclass PathUtils {\n  /**\n   * Joins path segments using platform separator\n   * @param {...string} paths - Path segments to join\n   * @returns {string} Joined path\n   * @example\n   * join('/tmp', 'test', 'file.txt')\n   * // → '/tmp/test/file.txt' (Unix)\n   * // → '\\tmp\\test\\file.txt' (Windows)\n   */\n  static join(...paths) {\n    return paths.join(pathSep);\n  }\n  \n  /**\n   * Gets directory name from path\n   * @param {string} path - File path\n   * @returns {string} Directory path\n   * @example\n   * dirname('/tmp/test/file.txt')\n   * // → '/tmp/test'\n   */\n  static dirname(path) {\n    const sep = pathSep;\n    const lastIndex = path.lastIndexOf(sep);\n    return lastIndex === -1 ? \".\" : path.substring(0, lastIndex);\n  }\n  \n  /**\n   * Gets filename from path\n   * @param {string} path - File path\n   * @param {string} [ext=''] - Extension to remove\n   * @returns {string} Filename\n   * @example\n   * basename('/tmp/test/file.txt')\n   * // → 'file.txt'\n   * basename('/tmp/test/file.txt', '.txt')\n   * // → 'file'\n   */\n  static basename(path, ext = \"\") {\n    const sep = pathSep;\n    const lastIndex = path.lastIndexOf(sep);\n    const base = lastIndex === -1 ? path : path.substring(lastIndex + 1);\n    return ext && base.endsWith(ext) \n      ? base.substring(0, base.length - ext.length)\n      : base;\n  }\n  \n  /**\n   * Gets file extension from path\n   * @param {string} path - File path\n   * @returns {string} Extension including dot\n   * @example\n   * extname('/tmp/test/file.txt')\n   * // → '.txt'\n   * extname('/tmp/test/file')\n   * // → ''\n   */\n  static extname(path) {\n    const lastDot = path.lastIndexOf(\".\");\n    return lastDot === -1 ? \"\" : path.substring(lastDot);\n  }\n}\n\n\n// Initialize docs on module load\n// Export public API (maintain backward compatibility)\nexport const read = FileOps.read;\nexport const write = FileOps.write;\nexport const readBytes = FileOps.readBytes;\nexport const writeBytes = FileOps.writeBytes;\nexport const exists = FileOps.exists;\nexport const stat = FileOps.stat;\n\nexport const mkdir = DirOps.mkdir;\nexport const readdir = DirOps.readdir;\nexport const remove = DirOps.remove;\nexport const copy = DirOps.copy;\nexport const move = DirOps.move;\n\nexport const join = PathUtils.join;\nexport const dirname = PathUtils.dirname;\nexport const basename = PathUtils.basename;\nexport const extname = PathUtils.extname;",
  "io/clipboard.js": "// Clipboard module - Cross-platform clipboard operations\n\nimport { platformCommand, PowerShellTemplates, checkSuccess, initializeDocs } from \"../core/utils.js\";\n\n/**\n * Reads text from system clipboard\n * @returns {Promise<string>} Clipboard text content\n * @example\n * await read()\n * // → \"Hello from clipboard\"\n */\nexport async function read() {\n  const result = await platformCommand({\n    darwin: { cmd: \"pbpaste\", args: [] },\n    windows: { script: PowerShellTemplates.getClipboard },\n    linux: [\n      { cmd: \"xclip\", args: [\"-selection\", \"clipboard\", \"-o\"] },\n      { cmd: \"xsel\", args: [\"--clipboard\", \"--output\"] },\n      { cmd: \"wl-paste\", args: [] }\n    ]\n  });\n  \n  // Clean Windows line endings\n  return result.stdout.replace(/\\r\\n$/, '');\n}\n\n/**\n * Writes text to system clipboard\n * @param {string} text - Text to write to clipboard\n * @returns {Promise<void>}\n * @example\n * await write(\"Hello clipboard\")\n * // → Text copied to clipboard\n */\nexport async function write(text) {\n  // For darwin/linux, we need stdin support\n  const writeWithStdin = async (cmd, args) => {\n    const p = new Deno.Command(cmd, { args, stdin: \"piped\" });\n    const proc = p.spawn();\n    const writer = proc.stdin.getWriter();\n    await writer.write(new TextEncoder().encode(text));\n    await writer.close();\n    const status = await proc.status;\n    return { success: status.success, stdout: \"\", stderr: \"\", code: status.code };\n  };\n  \n  // Darwin uses stdin\n  if (globalThis.Deno.build.os === \"darwin\") {\n    const result = await writeWithStdin(\"pbcopy\", []);\n    checkSuccess(result, \"Clipboard write\");\n    return;\n  }\n  \n  // Windows uses PowerShell\n  if (globalThis.Deno.build.os === \"windows\") {\n    const result = await platformCommand({\n      windows: { script: PowerShellTemplates.setClipboard(text) }\n    });\n    checkSuccess(result, \"Clipboard write\");\n    return;\n  }\n  \n  // Linux tries multiple tools with stdin\n  const tools = [\n    { cmd: \"xclip\", args: [\"-selection\", \"clipboard\"] },\n    { cmd: \"xsel\", args: [\"--clipboard\", \"--input\"] },\n    { cmd: \"wl-copy\", args: [] }\n  ];\n  \n  for (const tool of tools) {\n    try {\n      const result = await writeWithStdin(tool.cmd, tool.args);\n      if (result.success) return;\n    } catch {\n      // Try next tool\n    }\n  }\n  \n  throw new Error(\"Clipboard write failed. Install one of: xclip, xsel, or wl-clipboard\");\n}\n\n/**\n * Checks if clipboard operations are available\n * @returns {Promise<boolean>} True if clipboard is available\n * @example\n * await isAvailable()\n * // → true (on macOS/Windows)\n * // → false (on Linux without xclip/xsel)\n */\nexport async function isAvailable() {\n  try {\n    const os = globalThis.Deno.build.os;\n    if (os === \"darwin\" || os === \"windows\") {\n      return true; // Built-in support\n    }\n    \n    // Linux: Check for tools\n    const tools = [\"xclip\", \"xsel\", \"wl-paste\"];\n    for (const tool of tools) {\n      try {\n        const p = new Deno.Command(\"which\", { args: [tool] });\n        const { success } = await p.output();\n        if (success) return true;\n      } catch {}\n    }\n    return false;\n  } catch {\n    return false;\n  }\n}\n\n// Initialize docs on module load\ninitializeDocs({ read, write, isAvailable }, {\n  read: `read()\nReads text from system clipboard\nReturns: clipboard text content`,\n  \n  write: `write(text)\nWrites text to system clipboard\nParameters: text - string to copy`,\n  \n  isAvailable: `isAvailable()\nChecks if clipboard operations are available\nReturns: true if clipboard is available`\n});\n",
  "ui/control.js": "// UI Control Module - Control macOS GUI via WebSocket\n// Replaces __HLVM_COMMAND__ strings with proper JSON-RPC calls\n\nlet socket = null;\nlet requestId = 0;\nconst pending = new Map();\n\n// Connect to macOS app WebSocket server\nasync function connect(port = 11436) {\n  return new Promise((resolve, reject) => {\n    try {\n      socket = new WebSocket(`ws://localhost:${port}`);\n      \n      socket.onopen = () => {\n        console.log(\"Connected to macOS app\");\n        resolve(true);\n      };\n      \n      socket.onerror = (error) => {\n        reject(new Error(`Connection failed: ${error}`));\n      };\n      \n      socket.onmessage = (event) => {\n        try {\n          const msg = JSON.parse(event.data);\n          \n          // Handle response to our request\n          if (msg.id && pending.has(msg.id)) {\n            const { resolve, reject } = pending.get(msg.id);\n            pending.delete(msg.id);\n            \n            if (msg.error) {\n              reject(new Error(msg.error.message));\n            } else {\n              resolve(msg.result);\n            }\n          }\n          \n          // Handle notifications from app\n          if (!msg.id && msg.method) {\n            handleNotification(msg.method, msg.params);\n          }\n        } catch (e) {\n          console.error(\"Message handling error:\", e);\n        }\n      };\n      \n      socket.onclose = () => {\n        console.log(\"Disconnected from macOS app\");\n        socket = null;\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n// Send JSON-RPC request and wait for response\nasync function request(method, params = null) {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    // Try to connect\n    try {\n      await connect();\n    } catch {\n      return { error: \"macOS app not available\" };\n    }\n  }\n  \n  const id = `req-${++requestId}`;\n  \n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      pending.delete(id);\n      reject(new Error(\"Request timeout\"));\n    }, 5000);\n    \n    pending.set(id, { \n      resolve: (result) => {\n        clearTimeout(timeout);\n        resolve(result);\n      }, \n      reject: (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n    \n    const request = {\n      jsonrpc: \"2.0\",\n      id,\n      method,\n      params\n    };\n    \n    socket.send(JSON.stringify(request));\n  });\n}\n\n// Send notification (no response expected)\nfunction notify(method, params = null) {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn(\"App not connected\");\n    return;\n  }\n  \n  const notification = {\n    jsonrpc: \"2.0\",\n    method,\n    params\n  };\n  \n  socket.send(JSON.stringify(notification));\n}\n\n// Handle notifications from app\nfunction handleNotification(method, params) {\n  console.log(`Notification from app: ${method}`, params);\n  \n  // Emit events if needed\n  if (globalThis.hlvm?.events) {\n    globalThis.hlvm.events.emit(method, params);\n  }\n}\n\n// UI control commands (replacing __HLVM_COMMAND__ strings)\nexport const ui = {\n  // Connection management\n  connect,\n  disconnect: () => {\n    if (socket) {\n      socket.close();\n      socket = null;\n    }\n  },\n  \n  isConnected: () => socket && socket.readyState === WebSocket.OPEN,\n  \n  // Spotlight commands (replacing __HLVM_SPOTLIGHT_*)\n  spotlight: {\n    toggle: () => request(\"spotlight.toggle\"),\n    show: () => request(\"spotlight.show\"),\n    hide: () => request(\"spotlight.hide\"),\n    navigateIn: () => request(\"spotlight.navigateIn\"),\n    navigateOut: () => request(\"spotlight.navigateOut\"),\n    search: (query) => request(\"spotlight.search\", { query }),\n    \n    // Note: Module management moved to hlvm.modules for generic use\n  },\n  \n  // Chat commands (replacing __HLVM_CHAT_*)\n  chat: {\n    toggle: () => request(\"chat.toggle\"),\n    stop: () => request(\"chat.stop\"),\n    cancel: () => request(\"chat.cancel\"),\n    createRoom: (name) => request(\"chat.createRoom\", { name }),\n    send: (message) => request(\"chat.send\", { message }),\n    list: () => request(\"chat.list\"),\n    selectRoom: (id) => request(\"chat.selectRoom\", { id }),\n    ask: (prompt) => request(\"chat.ask\", { prompt })\n  },\n  \n  // Playground commands (replacing __HLVM_PLAYGROUND_*)\n  playground: {\n    toggle: () => request(\"playground.toggle\"),\n    eval: (code) => request(\"playground.eval\", { code }),\n    increaseFont: () => request(\"playground.increaseFont\"),\n    decreaseFont: () => request(\"playground.decreaseFont\"),\n    setCode: (code) => request(\"playground.setCode\", { code })\n  },\n  \n  // Screenshot commands (replacing __HLVM_SCREENSHOT_*)\n  screenshot: {\n    capture: () => request(\"screenshot.capture\"),\n    captureScreen: () => request(\"screenshot.captureScreen\"),\n    captureEntire: () => request(\"screenshot.captureEntire\"),\n    captureSelection: () => request(\"screenshot.captureSelection\")\n  },\n  \n  // App commands (replacing __HLVM_APP_*)\n  preferences: () => request(\"app.preferences\"),\n  escape: () => request(\"app.escape\"),\n  eval: (code) => request(\"app.eval\", { code }),\n  settings: () => request(\"app.settings\"),\n  textEditor: () => request(\"app.textEditor\"),\n  minimize: () => request(\"app.minimize\"),\n  quit: () => request(\"app.quit\"),\n  \n  // Code commands (replacing __HLVM_CODE_*)\n  code: {\n    paste: (code) => request(\"code.paste\", { code }),\n    copy: () => request(\"code.copy\")\n  },\n  \n  // Utility commands\n  // Note: Clipboard operations use hlvm.clipboard directly (not via WebSocket)\n  \n  // REPL commands\n  repl: {\n    toggle: () => request(\"repl.toggle\"),\n    clear: () => request(\"repl.clear\"),\n    execute: (code) => request(\"repl.execute\", { code })\n  },\n  \n  // AI commands\n  ai: {\n    write: (prompt) => request(\"ai.write\", { prompt })\n  },\n  \n  // Raw request for custom commands\n  request,\n  notify\n};\n\nexport default ui;"
};

export const embeddedInit = "// HLVM Initialization - Clean Mediator\n// Imports all stdlib modules and exposes them through the hlvm namespace\n\n\n// Import all stdlib modules from organized structure\nimport * as platform from \"./stdlib/core/platform.js\";\nimport * as system from \"./stdlib/core/system.js\";\nimport * as db from \"./stdlib/core/database.js\";\nimport * as fs from \"./stdlib/fs/filesystem.js\";\nimport * as clipboard from \"./stdlib/io/clipboard.js\";\nimport * as notification from \"./stdlib/computer/notification.js\";\nimport * as screen from \"./stdlib/computer/screen.js\";\nimport * as keyboard from \"./stdlib/computer/keyboard.js\";\nimport * as mouse from \"./stdlib/computer/mouse.js\";\nimport * as ollama from \"./stdlib/ai/ollama.js\";\nimport ui from \"./stdlib/ui/control.js\";\nimport appControl from \"./stdlib/app/control.js\";\nimport { context as computerContext } from \"./stdlib/computer/context.js\";\n\n// Import stdlib AI module (default export)\nimport stdlibAI from \"./stdlib/ai.js\";\n\n// Import core event module\nimport * as event from \"./stdlib/core/event.js\";\n\n// Import environment settings module\nimport * as env from \"./stdlib/core/env.js\";\n\n// Import documentation registry\nimport docRegistry from \"./stdlib/documentation.js\";\n\n// Create hlvm namespace inside IIFE to hide from global scope\n// Use void to prevent output when executed in REPL\nvoid (globalThis.hlvm = (() => {\n  const hlvmBase = {\n    // LAYER 1: Core primitives - all building blocks\n    core: {\n      // System - OS/environment stuff (merge platform + system)\n      system: {\n        // Info & platform\n        os: platform.os,\n        arch: platform.arch,\n        version: platform.version,\n        hostname: system.hostname,\n        pid: system.pid,\n        isDarwin: platform.isDarwin,\n        isWindows: platform.isWindows,\n        isLinux: platform.isLinux,\n        \n        // Working directory & paths\n        homeDir: platform.homeDir,\n        tempDir: platform.tempDir,\n        cwd: system.cwd,\n        chdir: system.chdir,\n        pathSep: platform.pathSep,\n        exeExt: platform.exeExt,\n        \n        // Environment & execution\n        env: system.env,\n        exit: system.exit,\n        exec: system.exec,\n        shell: platform.shell,\n        powershell: platform.powershell,\n        \n        // Utilities\n        escapeShell: platform.escapeShell,\n        escapeKeyboard: platform.escapeKeyboard,\n        decode: platform.decode,\n        linuxTool: platform.linuxTool,\n        \n        // Constants\n        PS: platform.PS,\n        ERRORS: platform.ERRORS\n      },\n      \n      // Storage - persistence\n      storage: {\n        db: Object.assign(db.db, {\n          path: db.path,\n          load: db.load,\n          getSource: db.getSource\n        }),\n        // ESM modules collection (renamed from modules for clarity)\n        esm: {\n          set: db.save,  // Renamed from save for consistency\n          get: db.getSource,\n          list: db.list,\n          remove: async (name) => {\n            // If no name given, remove ALL modules (nuke)\n            if (!name) {\n              const allModules = db.list();\n              for (const mod of allModules) {\n                await db.remove(mod.key);\n              }\n              console.log(`Removed all ${allModules.length} modules`);\n              return true;\n            }\n            // Otherwise remove specific module\n            return db.remove(name);\n          },\n          has: async (name) => {\n            const modules = db.list();\n            return modules.some(m => m.key === name);\n          },\n          load: db.load  // Keep load as it executes the module\n        }\n      },\n      \n      // IO - input/output\n      io: {\n        fs: {\n          read: fs.read,\n          write: fs.write,\n          readBytes: fs.readBytes,\n          writeBytes: fs.writeBytes,\n          exists: fs.exists,\n          stat: fs.stat,\n          remove: fs.remove,\n          copy: fs.copy,\n          move: fs.move,\n          mkdir: fs.mkdir,\n          readdir: fs.readdir,\n          // Path utilities stay here (fs context)\n          join: fs.join,\n          dirname: fs.dirname,\n          basename: fs.basename,\n          extname: fs.extname\n        },\n        clipboard: {\n          isAvailable: clipboard.isAvailable,\n          read: clipboard.read,\n          write: clipboard.write\n        }\n      },\n      \n      // Computer - automation\n      computer: {\n        keyboard: {\n          type: keyboard.type,\n          press: keyboard.press,\n          onKeyPress: keyboard.onKeyPress,\n          offKeyPress: keyboard.offKeyPress,\n          listKeyListeners: keyboard.listKeyListeners\n        },\n        mouse: {\n          move: mouse.move,\n          click: mouse.click,\n          doubleClick: mouse.doubleClick,\n          drag: mouse.drag,\n          position: mouse.position\n        },\n        screen: {\n          capture: screen.capture,\n          getScreenSize: screen.getScreenSize\n        },\n        context: computerContext\n      },\n      \n      // UI - user interface\n      ui: {\n        notification: {\n          alert: notification.alert,\n          confirm: notification.confirm,\n          notify: notification.notify,\n          prompt: notification.prompt\n        }\n      },\n      \n      // AI - AI services\n      ai: {\n        ollama: ollama\n      },\n      \n      // Event - observation system\n      event: {\n        observe: event.observe,\n        unobserve: event.unobserve,\n        list: event.list\n      },\n      \n      // Global aliases - create shortcuts to any hlvm path\n      alias: {\n        set: async (name, path) => createAlias(name, path),\n        get: (name) => getAlias(name),\n        list: () => listAliases(),\n        remove: async (name) => removeAlias(name),\n        has: (name) => hasAlias(name),\n        // Show all aliases in a nice format\n        show: function(filter) {\n          const aliases = listAliases();\n          \n          // If filter provided, filter by name or path\n          let filtered = aliases;\n          if (filter) {\n            const lowerFilter = filter.toLowerCase();\n            filtered = aliases.filter(a => \n              a.name.toLowerCase().includes(lowerFilter) || \n              a.path.toLowerCase().includes(lowerFilter)\n            );\n          }\n          \n          if (filtered.length === 0) {\n            if (filter) {\n              console.log(`\\x1b[33mNo global functions matching '${filter}'\\x1b[0m`);\n            } else {\n              console.log(`\\x1b[33mNo global aliases registered yet.\\x1b[0m`);\n              console.log(`\\x1b[90mCreate one with: hlvm.core.alias.set('name', 'path.to.function')\\x1b[0m`);\n              console.log(`\\x1b[90mExample: hlvm.core.alias.set('ask', 'hlvm.stdlib.ai.ask')\\x1b[0m`);\n            }\n            return [];\n          }\n          \n          // Display in a nice format\n          console.log(`\\n\\x1b[36m═══ Global Aliases${filter ? ` (filtered: ${filter})` : ''} ═══\\x1b[0m\\n`);\n          \n          // Group by category if possible\n          const categorized = {};\n          filtered.forEach(alias => {\n            // Try to categorize by path prefix\n            let category = 'Custom';\n            if (alias.path.includes('.ai.')) category = 'AI';\n            else if (alias.path.includes('.fs.')) category = 'File System';\n            else if (alias.path.includes('.clipboard.')) category = 'Clipboard';\n            else if (alias.path.includes('.system.')) category = 'System';\n            else if (alias.path.includes('.computer.')) category = 'Automation';\n            else if (alias.path.includes('.notification.')) category = 'UI';\n            \n            if (!categorized[category]) categorized[category] = [];\n            categorized[category].push(alias);\n          });\n          \n          // Display categorized\n          Object.keys(categorized).sort().forEach(category => {\n            console.log(`\\x1b[33m${category}:\\x1b[0m`);\n            categorized[category].sort((a, b) => a.name.localeCompare(b.name)).forEach(alias => {\n              const padding = ' '.repeat(Math.max(1, 20 - alias.name.length));\n              console.log(`  \\x1b[32m${alias.name}()\\x1b[0m${padding}→ \\x1b[90m${alias.path}\\x1b[0m`);\n            });\n            console.log();\n          });\n          \n          console.log(`\\x1b[90mTotal: ${filtered.length} function${filtered.length !== 1 ? 's' : ''}\\x1b[0m`);\n          if (filtered.length > 0) {\n            console.log(`\\x1b[90mUse help('${filtered[0].name}') or help(${filtered[0].name}) for documentation\\x1b[0m\\n`);\n          }\n          \n          // Show documentation for each function\n          console.log(`\\x1b[36m═══ Documentation ═══\\x1b[0m\\n`);\n          \n          filtered.forEach(alias => {\n            // Check if documentation exists for this path\n            if (docRegistry.has(alias.path)) {\n              console.log(docRegistry.get(alias.path));\n              console.log(); // Add spacing between docs\n            } else {\n              // Show basic info if no documentation\n              console.log(`\\x1b[36m${alias.name}()\\x1b[0m`);\n              console.log(`Path: ${alias.path}`);\n              console.log(`\\x1b[90mNo detailed documentation available\\x1b[0m\\n`);\n            }\n          });\n          \n          return filtered;\n        }\n      }\n    },\n    \n    // LAYER 2: App control (top-level, not core!)\n    app: {\n      // HLVM's own UI controls (WebSocket bridge, etc.)\n      hlvm: ui,\n      \n      // External app control (cross-platform)\n      get: appControl.get,\n      list: appControl.list,\n      frontmost: appControl.frontmost,\n      aliases: appControl.aliases,\n      isAvailable: appControl.isAvailable\n    },\n    \n    // LAYER 3: High-level stdlib\n    stdlib: {\n      ai: {\n        revise: stdlibAI.revise,\n        draw: stdlibAI.draw,\n        refactor: stdlibAI.refactor,\n        chat: stdlibAI.chat,\n        ask: stdlibAI.ask,\n        judge: stdlibAI.judge\n      }\n    },\n    \n    // Environment settings (persistent configuration)\n    env: env,\n    \n    // Context - returns context object (keep at root for convenience)\n    get context() {\n      return hlvmBase.core.computer.context;\n    },\n  \n  // Help\n  help: () => {\n    // Get current aliases for display\n    const aliases = listAliases();\n    const hasAliases = aliases.length > 0;\n    \n    console.log(`\n\\x1b[36m═══════════════════════════════════════════════════════════════\\x1b[0m\n\\x1b[36m                    HLVM QUICK START GUIDE\\x1b[0m\n\\x1b[36m═══════════════════════════════════════════════════════════════\\x1b[0m\n\n\\x1b[33m🚀 DISCOVERY COMMANDS:\\x1b[0m\n  \\x1b[32malias()\\x1b[0m                  - List all global aliases you can use\n  \\x1b[32mhelp('name')\\x1b[0m             - Get help for specific function (e.g., help('ask'))\n  \\x1b[32mhelp(functionName)\\x1b[0m       - Get help for function object (e.g., help(ask))\n  \n${hasAliases ? `\\x1b[33m📦 YOUR GLOBAL ALIASES:\\x1b[0m\n${aliases.map(a => `  \\x1b[32m${a.name}()\\x1b[0m${' '.repeat(Math.max(1, 24 - a.name.length))}→ ${a.path}`).join('\\n')}\n` : `\\x1b[33m📦 NO GLOBAL ALIASES YET:\\x1b[0m\n  Create your first one:\n  \\x1b[90mhlvm.core.alias.set('ask', 'hlvm.stdlib.ai.ask')\\x1b[0m\n  \\x1b[90mhlvm.core.alias.set('read', 'hlvm.core.io.fs.read')\\x1b[0m\n`}\n\\x1b[33m🎯 COMMON TASKS:\\x1b[0m\n  \\x1b[90m// AI Chat\\x1b[0m\n  await hlvm.stdlib.ai.ask(\"What is quantum computing?\")\n  \n  \\x1b[90m// Text Revision\\x1b[0m\n  await hlvm.stdlib.ai.revise(\"fix this text plz\")\n  \n  \\x1b[90m// File Operations\\x1b[0m\n  await hlvm.core.io.fs.write('/tmp/test.txt', 'Hello')\n  await hlvm.core.io.fs.read('/tmp/test.txt')\n  \n  \\x1b[90m// Clipboard\\x1b[0m\n  await hlvm.core.io.clipboard.write(\"text\")\n  await hlvm.core.io.clipboard.read()\n\n\\x1b[33m📚 MAIN NAMESPACES:\\x1b[0m\n  \\x1b[36mhlvm.core\\x1b[0m               - Core system functions\n  \\x1b[36mhlvm.stdlib\\x1b[0m             - High-level utilities\n  \\x1b[36mhlvm.app\\x1b[0m                - Application control\n  \\x1b[36mhlvm.env\\x1b[0m                - Environment settings\n\n\\x1b[33m💡 TIPS:\\x1b[0m\n  • Type \\x1b[32malias()\\x1b[0m to see all your global aliases\n  • Use \\x1b[32mhlvm.<TAB>\\x1b[0m to explore the API\n  • Create shortcuts: \\x1b[90mhlvm.core.alias.set('clip', 'hlvm.core.io.clipboard.read')\\x1b[0m\n  • Get detailed docs: \\x1b[90mhelp('hlvm.core.io.fs.read')\\x1b[0m\n\n\\x1b[36m═══════════════════════════════════════════════════════════════\\x1b[0m\n    `);\n  },\n  \n  // Status\n  status: () => {\n    const modules = Object.keys(hlvm).filter(k => typeof hlvm[k] === 'object');\n    const savedModules = hlvmBase.core.storage.esm.list();\n    \n    console.log('\\nHLVM Status:');\n    console.log('─'.repeat(40));\n    console.log('Top-level:', modules.join(', '));\n    console.log(`Saved Modules: ${savedModules.length} modules`);\n    console.log(`Database: ${hlvmBase.core.storage.db.path}`);\n    console.log(`Platform: ${hlvmBase.core.system.os} (${hlvmBase.core.system.arch}`);\n    console.log(`Temp Dir: ${hlvmBase.core.system.tempDir()}`);\n    console.log(`Home Dir: ${hlvmBase.core.system.homeDir()}`);\n  }\n  };\n  \n  // Add user storage namespace for user-defined properties (before setting null prototypes)\n  hlvmBase.core.storage.user = {};  // Will be populated after setupCustomPropertyPersistence\n\n  // NOTE: We're NOT setting null prototypes as it breaks Deno's tab completion.\n  // The trade-off is we'll see Object.prototype methods (toString, valueOf, etc.)\n  // but tab completion will work properly at all nested levels.\n\n  // Setup alias persistence\n  function setupAliases() {\n    // Create aliases table if not exists\n    db.db.exec(`\n    CREATE TABLE IF NOT EXISTS aliases (\n      name TEXT PRIMARY KEY,\n      path TEXT NOT NULL,\n      created_at INTEGER NOT NULL,\n      updated_at INTEGER NOT NULL\n    )\n  `);\n  \n  // Load existing aliases and create global functions\n  const aliases = db.db.prepare('SELECT * FROM aliases').all();\n  aliases.forEach(alias => {\n    try {\n      // Create the global alias function\n      globalThis[alias.name] = async (...args) => {\n        // Navigate the path to find the function\n        const parts = alias.path.split('.');\n        let current = globalThis;\n        for (const part of parts) {\n          current = current[part];\n          if (!current) {\n            throw new Error(`Path ${alias.path} not found`);\n          }\n        }\n        \n        // Call the function if it's callable\n        if (typeof current === 'function') {\n          return await current(...args);\n        }\n        return current;\n      };\n    } catch (e) {\n      console.error(`Failed to restore alias '${alias.name}':`, e.message);\n    }\n  });\n  \n  // Always ensure alias() is available as a global function\n  if (!aliases.some(a => a.name === 'alias')) {\n    // Create alias function directly without going through createAlias to avoid circular dependency\n    globalThis.alias = (...args) => hlvmBase.core.alias.show(...args);\n  }\n  \n  // Show available global aliases after they are loaded\n  // Filter out 'alias' from the display since it's always available\n  const userAliases = aliases.filter(a => a.name !== 'alias');\n  if (userAliases.length > 0) {\n    const aliasNames = userAliases.map(a => a.name).sort().join(', ');\n    console.log(`\\x1b[33mGlobal aliases: ${aliasNames}\\x1b[0m`);\n    console.log(`\\x1b[90mType alias() to list all, help('name') for docs, or hlvm.core.alias.set() to create new\\x1b[0m`);\n  } else {\n    console.log(`\\x1b[33mNo global aliases yet.\\x1b[0m \\x1b[90mCreate one with hlvm.core.alias.set('name', 'path')\\x1b[0m`);\n    console.log(`\\x1b[90mType alias() to see examples\\x1b[0m`);\n  }\n}\n\n  // Create an alias\n  function createAlias(name, path) {\n  // Validate name doesn't conflict with system\n  const reserved = ['hlvm', 'Deno', 'console', 'global', 'globalThis', 'window', \n                    'document', 'alert', 'confirm', 'prompt', 'eval', 'Function',\n                    'Object', 'Array', 'String', 'Number', 'Boolean', 'Symbol',\n                    'Math', 'Date', 'RegExp', 'Error', 'JSON', 'Promise'];\n  \n  if (reserved.includes(name)) {\n    throw new Error(`Cannot use reserved name '${name}' for alias`);\n  }\n  \n  // Save to database\n  const now = Date.now();\n  db.db.prepare(`\n    INSERT OR REPLACE INTO aliases (name, path, created_at, updated_at)\n    VALUES (?, ?, ?, ?)\n  `).run(name, path, now, now);\n  \n  // Create the global function\n  globalThis[name] = async (...args) => {\n    const parts = path.split('.');\n    let current = globalThis;\n    for (const part of parts) {\n      current = current[part];\n      if (!current) {\n        throw new Error(`Path ${path} not found`);\n      }\n    }\n    \n    if (typeof current === 'function') {\n      return await current(...args);\n    }\n    return current;\n  };\n  \n  console.log(`✅ Created alias: ${name}() → ${path}`);\n  return true;\n}\n\n  // Remove an alias\n  function removeAlias(name) {\n  // Remove from database\n  db.db.prepare('DELETE FROM aliases WHERE name = ?').run(name);\n  \n  // Remove from global scope\n  delete globalThis[name];\n  \n  console.log(`✅ Removed alias: ${name}`);\n  return true;\n}\n\n  // Get a specific alias\n  function getAlias(name) {\n  const alias = db.db.prepare('SELECT * FROM aliases WHERE name = ?').get(name);\n  if (!alias) return null;\n  return {\n    name: alias.name,\n    path: alias.path,\n    createdAt: new Date(alias.created_at),\n    updatedAt: new Date(alias.updated_at)\n  };\n}\n\n  // List all aliases\n  function listAliases() {\n  const aliases = db.db.prepare('SELECT * FROM aliases ORDER BY name').all();\n  return aliases.map(s => ({\n    name: s.name,\n    path: s.path,\n    createdAt: new Date(s.created_at),\n    updatedAt: new Date(s.updated_at)\n  }));\n}\n\n  // Check if alias exists\n  function hasAlias(name) {\n  const alias = db.db.prepare('SELECT 1 FROM aliases WHERE name = ?').get(name);\n  return !!alias;\n}\n\n  // Create custom properties table if not exists (moved from setupCustomPropertyPersistence)\n  function setupCustomPropertiesTable() {\n    db.db.exec(`\n      CREATE TABLE IF NOT EXISTS custom_properties (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        type TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      )\n    `);\n  }\n\n  // Function to recursively convert all objects to null prototype\n  function cleanObject(obj) {\n    if (obj === null || obj === undefined) return obj;\n    if (typeof obj !== 'object') return obj;\n    if (typeof obj === 'function') return obj;\n    if (Array.isArray(obj)) return obj;\n    \n    // Create new object with null prototype\n    const clean = Object.create(null);\n    \n    // Copy all properties\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const value = obj[key];\n        // Recursively clean nested objects\n        if (value && typeof value === 'object' && !Array.isArray(value) && typeof value !== 'function') {\n          clean[key] = cleanObject(value);\n        } else {\n          clean[key] = value;\n        }\n      }\n    }\n    \n    return clean;\n  }\n  \n  // Clean the entire hlvmBase object tree to remove Object.prototype pollution\n  const cleanHlvm = cleanObject(hlvmBase);\n  \n  // Setup persistence (must be after cleanHlvm is created)\n  setupAliases();\n  setupCustomPropertiesTable();\n\n  // Wrap in Proxy for auto-persist custom properties - uses storage.user infrastructure\n  const hlvmProxy = new Proxy(cleanHlvm, {\n    set(target, prop, value) {\n      // Delegate ALL to storage.user.set - it handles system prop filtering\n      hlvmBase.core.storage.user.set(prop, value);\n      return true;\n    },\n    \n    deleteProperty(target, prop) {\n      // Delegate ALL to storage.user.remove - it handles system prop filtering  \n      hlvmBase.core.storage.user.remove(prop);\n      return true;\n    },\n    \n    // CRITICAL: These traps are required for tab completion to work in Deno REPL\n    // Use Reflect to properly forward all operations\n    has(target, prop) {\n      return Reflect.has(target, prop);\n    },\n    \n    ownKeys(target) {\n      return Reflect.ownKeys(target);\n    },\n    \n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    \n    get(target, prop) {\n      return Reflect.get(target, prop);\n    }\n  });\n\n  // Define reusable helpers for user storage (DRY)\n  const SYSTEM_PROPS = ['core', 'app', 'stdlib', 'env', 'context', 'help', 'status'];\n  \n  const isSystemProp = (key) => SYSTEM_PROPS.includes(key);\n  const isUserProp = (key) => !isSystemProp(key);\n  \n  const serializeValue = (value) => {\n    if (value === null) return { serialized: 'null', type: 'null' };\n    if (value === undefined) return { serialized: 'undefined', type: 'undefined' };\n    const type = typeof value;\n    const serialized = type === 'function' ? value.toString() : JSON.stringify(value);\n    return { serialized, type };\n  };\n  \n  const persistToDb = (key, value) => {\n    const { serialized, type } = serializeValue(value);\n    db.db.prepare(`\n      INSERT OR REPLACE INTO custom_properties (key, value, type, updated_at)\n      VALUES (?, ?, ?, ?)\n    `).run(key, serialized, type, Date.now());\n  };\n  \n  const removeFromDb = (key) => {\n    db.db.prepare('DELETE FROM custom_properties WHERE key = ?').run(key);\n  };\n  \n  // Populate the user storage methods - single source of truth for all user data persistence\n  hlvmBase.core.storage.user.set = function(key, value) {\n    // System properties - just set directly, no persistence\n    if (isSystemProp(key)) {\n      cleanHlvm[key] = value;\n      return value;\n    }\n    \n    // User properties - persist to database (including null/undefined)\n    persistToDb(key, value);\n    cleanHlvm[key] = value;\n    return value;\n  };\n  \n  hlvmBase.core.storage.user.get = function(key) {\n    return cleanHlvm[key];\n  };\n  \n  hlvmBase.core.storage.user.remove = function(key) {\n    // System properties - just delete, no database\n    if (isSystemProp(key)) {\n      delete cleanHlvm[key];\n      return true;\n    }\n    \n    // User properties - remove from database\n    if (key in cleanHlvm) {\n      removeFromDb(key);\n      delete cleanHlvm[key];\n    }\n    return true;\n  };\n  \n  hlvmBase.core.storage.user.list = function() {\n    const props = db.db.prepare('SELECT * FROM custom_properties ORDER BY key').all();\n    return props.map(p => ({\n      key: p.key,\n      type: p.type,\n      updatedAt: new Date(p.updated_at)\n    }));\n  };\n  \n  hlvmBase.core.storage.user.has = function(key) {\n    return (key in cleanHlvm) && isUserProp(key);\n  };\n  \n  // Load existing custom properties from database\n  hlvmBase.core.storage.user.load = function() {\n    const props = db.db.prepare('SELECT * FROM custom_properties').all();\n    props.forEach(prop => {\n      try {\n        if (prop.type === 'null') {\n          cleanHlvm[prop.key] = null;\n        } else if (prop.type === 'undefined') {\n          cleanHlvm[prop.key] = undefined;\n        } else if (prop.type === 'function') {\n          // Recreate function from string\n          cleanHlvm[prop.key] = eval(`(${prop.value})`);\n        } else {\n          cleanHlvm[prop.key] = JSON.parse(prop.value);\n        }\n      } catch (e) {\n        console.error(`Failed to restore custom property '${prop.key}':`, e.message);\n      }\n    });\n  };\n  \n  // Load user properties on startup\n  hlvmBase.core.storage.user.load();\n\n  // TEMPORARY: Return cleanHlvm directly without Proxy to test tab completion\n  // TODO: Find a better way to handle persistence that doesn't break tab completion\n  return cleanHlvm;\n  // return hlvmProxy;\n})());  // End IIFE - hlvmBase is now hidden from global scope - extra parens for void operator\n\n// Global utilities\nglobalThis.pprint = (obj) => console.log(JSON.stringify(obj, null, 2));\n\n// Global help function - shows general help or specific function documentation\nglobalThis.help = function(func) {\n  // If no argument, show general HLVM help\n  if (arguments.length === 0) {\n    // Call hlvm.help() for general help\n    if (globalThis.hlvm && globalThis.hlvm.help) {\n      globalThis.hlvm.help();\n    } else {\n      console.log('HLVM help not available');\n    }\n    return;\n  }\n  \n  // Otherwise show documentation for specific function\n  let path = '';\n  \n  // Handle string path like 'hlvm.core.io.fs.read'\n  if (typeof func === 'string') {\n    path = func;\n    // Look up documentation directly\n    if (docRegistry.has(path)) {\n      console.log(docRegistry.get(path));\n      return;\n    }\n    // Try to resolve the path to get the function\n    try {\n      const parts = func.split('.');\n      let current = globalThis;\n      for (const part of parts) {\n        current = current[part];\n        if (!current) {\n          console.log(`Path not found: ${func}`);\n          return;\n        }\n      }\n      func = current;\n    } catch (e) {\n      console.log(`Error accessing: ${func}`);\n      return;\n    }\n  }\n  \n  // Handle direct function - find its path\n  if (typeof func === 'function') {\n    // First check if this is a global alias\n    // Look for the function in global scope\n    let aliasName = null;\n    for (const key in globalThis) {\n      if (globalThis[key] === func && key !== 'doc' && key !== 'pprint') {\n        aliasName = key;\n        break;\n      }\n    }\n    \n    // If we found an alias, check the aliases table for its path\n    if (aliasName && globalThis.hlvm?.core?.storage?.db) {\n      try {\n        const aliasInfo = globalThis.hlvm.core.storage.db\n          .prepare('SELECT path FROM aliases WHERE name = ?')\n          .get(aliasName);\n        if (aliasInfo && aliasInfo.path) {\n          path = aliasInfo.path;\n          // Look up documentation with this path\n          if (docRegistry.has(path)) {\n            console.log(docRegistry.get(path));\n            return;\n          }\n        }\n      } catch (e) {\n        // Database query failed, continue with normal lookup\n      }\n    }\n    \n    // Try to find the path for this function in hlvm namespace\n    function findPath(obj, target, currentPath = '') {\n      for (const key in obj) {\n        const newPath = currentPath ? `${currentPath}.${key}` : key;\n        if (obj[key] === target) {\n          return newPath;\n        }\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\n          const found = findPath(obj[key], target, newPath);\n          if (found) return found;\n        }\n      }\n      return null;\n    }\n    path = findPath(globalThis.hlvm, func, 'hlvm');\n    \n    // Look up documentation\n    if (path && docRegistry.has(path)) {\n      console.log(docRegistry.get(path));\n    } else {\n      // No documentation found\n      const funcName = func.name || aliasName || 'anonymous';\n      console.log(`\\x1b[36m${funcName}(...)\\x1b[0m`);\n      console.log('\\nNo documentation available');\n    }\n  } else if (typeof func === 'object' && func !== null) {\n    // Show object properties\n    console.log(`\\x1b[36mObject\\x1b[0m`);\n    console.log('\\nProperties:');\n    for (const key in func) {\n      const type = typeof func[key];\n      console.log(`  ${key}: \\x1b[90m${type}\\x1b[0m`);\n    }\n  } else {\n    console.log('Usage: help(function) or help(\"path.to.function\")');\n  }\n};\n\n// Global shorthand for context - removed to prevent startup issues";
export const embeddedBridge = "// HLVM Bridge - WebSocket server for GUI control commands\n// NOTE: JavaScript eval uses stdin/stdout, NOT this WebSocket bridge\n// This bridge is only for hlvm.app GUI control commands\n\ninterface JSONRPCRequest {\n  jsonrpc: \"2.0\";\n  id?: string | number;\n  method: string;\n  params?: any;\n}\n\ninterface JSONRPCResponse {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}\n\ninterface JSONRPCNotification {\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: any;\n}\n\n// Handler types for better type safety\ntype HandlerFunction = (params: any) => Promise<any>;\ntype HandlerRegistry = Map<string, HandlerFunction>;\n\n// Separate handler classes following Single Responsibility Principle\nclass SystemHandlers {\n  static getInfo(): Promise<any> {\n    return Promise.resolve({\n      platform: Deno.build.os,\n      arch: Deno.build.arch,\n      version: \"2.0\",\n      pid: Deno.pid\n    });\n  }\n}\n\nclass ModuleHandlers {\n  static async list(): Promise<any> {\n    // Use actual core API that exists\n    return globalThis.hlvm?.core?.storage?.esm?.list?.() || [];\n  }\n\n  static async save(params: any): Promise<any> {\n    // Use actual core API that exists\n    if (!globalThis.hlvm?.core?.storage?.esm?.set) {\n      throw new Error(\"Module save not available\");\n    }\n    return globalThis.hlvm.core.storage.esm.set(params.name, params.code);\n  }\n\n  // Removed load method - GUI reads database directly instead\n}\n\nclass AIHandlers {\n  static async generate(params: any): Promise<any> {\n    if (!globalThis.hlvm?.ai?.ollama?.chat) {\n      throw new Error(\"AI not available\");\n    }\n    return globalThis.hlvm.ai.ollama.chat(params.prompt, params.model);\n  }\n}\n\nclass FileSystemHandlers {\n  static async read(params: any): Promise<string> {\n    return Deno.readTextFile(params.path);\n  }\n\n  static async write(params: any): Promise<{ success: boolean }> {\n    await Deno.writeTextFile(params.path, params.content);\n    return { success: true };\n  }\n\n  static async exists(params: any): Promise<boolean> {\n    try {\n      await Deno.stat(params.path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n// Connection manager for WebSocket connections\nclass ConnectionManager {\n  private connections = new Set<WebSocket>();\n\n  add(socket: WebSocket): void {\n    this.connections.add(socket);\n  }\n\n  remove(socket: WebSocket): void {\n    this.connections.delete(socket);\n  }\n\n  get size(): number {\n    return this.connections.size;\n  }\n\n  get all(): Set<WebSocket> {\n    return this.connections;\n  }\n\n  get first(): WebSocket | undefined {\n    return this.connections.values().next().value;\n  }\n\n  clear(): void {\n    for (const socket of this.connections) {\n      socket.close();\n    }\n    this.connections.clear();\n  }\n}\n\nclass HLVMBridge {\n  private connectionManager = new ConnectionManager();\n  private server?: Deno.HttpServer;\n  private handlers: HandlerRegistry = new Map();\n\n  constructor() {\n    this.registerHandlers();\n  }\n\n  private registerHandlers(): void {\n    // System handlers\n    this.handlers.set(\"system.info\", SystemHandlers.getInfo);\n\n    // Module handlers\n    this.handlers.set(\"modules.list\", ModuleHandlers.list);\n    this.handlers.set(\"modules.save\", ModuleHandlers.save);\n    // Removed modules.load - GUI reads database directly\n\n    // AI handlers\n    this.handlers.set(\"ai.generate\", AIHandlers.generate);\n\n    // File system handlers\n    this.handlers.set(\"fs.read\", FileSystemHandlers.read);\n    this.handlers.set(\"fs.write\", FileSystemHandlers.write);\n    this.handlers.set(\"fs.exists\", FileSystemHandlers.exists);\n  }\n\n  async start(port = 11436): Promise<void> {\n    this.server = Deno.serve({ \n      port, \n      onListen: () => console.log(`HLVM Bridge running on ws://localhost:${port}`)\n    }, (req) => this.handleRequest(req));\n  }\n\n  private handleRequest(req: Request): Response {\n    if (req.headers.get(\"upgrade\") === \"websocket\") {\n      return this.handleWebSocketUpgrade(req);\n    }\n    \n    if (req.url.endsWith(\"/health\")) {\n      return this.handleHealthCheck();\n    }\n    \n    return new Response(\"HLVM Bridge WebSocket Server\", { status: 200 });\n  }\n\n  private handleWebSocketUpgrade(req: Request): Response {\n    const { socket, response } = Deno.upgradeWebSocket(req);\n    \n    socket.onopen = () => this.handleSocketOpen(socket);\n    socket.onmessage = (event) => this.handleSocketMessage(socket, event);\n    socket.onclose = () => this.handleSocketClose(socket);\n    socket.onerror = (error) => console.error(\"WebSocket error:\", error);\n    \n    return response;\n  }\n\n  private handleSocketOpen(socket: WebSocket): void {\n    console.log(\"macOS app connected\");\n    this.connectionManager.add(socket);\n    this.sendConnectionNotification(socket);\n  }\n\n  private sendConnectionNotification(socket: WebSocket): void {\n    const notification: JSONRPCNotification = {\n      jsonrpc: \"2.0\",\n      method: \"connection.established\",\n      params: {\n        version: \"2.0\",\n        capabilities: Array.from(this.handlers.keys())\n      }\n    };\n    socket.send(JSON.stringify(notification));\n  }\n\n  private async handleSocketMessage(socket: WebSocket, event: MessageEvent): Promise<void> {\n    try {\n      const request = JSON.parse(event.data) as JSONRPCRequest;\n      \n      if (request.jsonrpc !== \"2.0\") {\n        throw new Error(\"Invalid JSON-RPC version\");\n      }\n\n      if (request.id !== undefined) {\n        await this.handleRequestWithResponse(socket, request);\n      } else {\n        await this.handleNotification(request);\n      }\n    } catch (error) {\n      console.error(\"Message handling error:\", error);\n    }\n  }\n\n  private async handleRequestWithResponse(socket: WebSocket, request: JSONRPCRequest): Promise<void> {\n    const response: JSONRPCResponse = {\n      jsonrpc: \"2.0\",\n      id: request.id!\n    };\n\n    try {\n      const handler = this.handlers.get(request.method);\n      if (!handler) {\n        response.error = {\n          code: -32601,\n          message: `Method not found: ${request.method}`\n        };\n      } else {\n        response.result = await handler(request.params);\n      }\n    } catch (error) {\n      response.error = {\n        code: -32603,\n        message: error.message\n      };\n    }\n\n    socket.send(JSON.stringify(response));\n  }\n\n  private async handleNotification(request: JSONRPCRequest): Promise<void> {\n    const handler = this.handlers.get(request.method);\n    if (handler) {\n      handler(request.params).catch(console.error);\n    }\n  }\n\n  private handleSocketClose(socket: WebSocket): void {\n    console.log(\"macOS app disconnected\");\n    this.connectionManager.remove(socket);\n  }\n\n  private handleHealthCheck(): Response {\n    return new Response(JSON.stringify({ \n      status: \"ok\", \n      connections: this.connectionManager.size \n    }), {\n      headers: { \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  broadcast(method: string, params?: any): void {\n    const notification: JSONRPCNotification = {\n      jsonrpc: \"2.0\",\n      method,\n      params\n    };\n    \n    const message = JSON.stringify(notification);\n    for (const socket of this.connectionManager.all) {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(message);\n      }\n    }\n  }\n\n  async request(method: string, params?: any): Promise<any> {\n    const socket = this.connectionManager.first;\n    if (!socket) {\n      throw new Error(\"No macOS app connected\");\n    }\n\n    return this.sendRequestAndWaitForResponse(socket, method, params);\n  }\n\n  private sendRequestAndWaitForResponse(socket: WebSocket, method: string, params?: any): Promise<any> {\n    const id = this.generateRequestId();\n    const timeoutMs = 5000;\n    \n    return new Promise((resolve, reject) => {\n      let handler: ((event: MessageEvent) => void) | null = null;\n      \n      const cleanup = () => {\n        if (handler) {\n          socket.removeEventListener(\"message\", handler);\n          handler = null;\n        }\n      };\n      \n      const timeout = setTimeout(() => {\n        cleanup();\n        reject(new Error(\"Request timeout\"));\n      }, timeoutMs);\n      \n      handler = this.createResponseHandler(id, timeout, resolve, reject, cleanup);\n      socket.addEventListener(\"message\", handler);\n      \n      const request: JSONRPCRequest = { jsonrpc: \"2.0\", id, method, params };\n      socket.send(JSON.stringify(request));\n    });\n  }\n\n  private generateRequestId(): string {\n    return `req-${Date.now()}-${Math.random()}`;\n  }\n\n  private createResponseHandler(\n    expectedId: string | number,\n    timeout: NodeJS.Timeout,\n    resolve: (value: any) => void,\n    reject: (reason: any) => void,\n    cleanup: () => void\n  ): (event: MessageEvent) => void {\n    return function handler(event: MessageEvent) {\n      try {\n        const response = JSON.parse(event.data) as JSONRPCResponse;\n        if (response.id === expectedId) {\n          clearTimeout(timeout);\n          cleanup();\n          \n          if (response.error) {\n            reject(new Error(response.error.message));\n          } else {\n            resolve(response.result);\n          }\n        }\n      } catch {}\n    };\n  }\n\n  stop(): void {\n    this.connectionManager.clear();\n    this.server?.shutdown();\n  }\n}\n\n// Export for use in HLVM\nexport { HLVMBridge };\nexport const bridge = new HLVMBridge();\n\n// Start bridge if running as standalone\nif (import.meta.main) {\n  await bridge.start(11436);\n}";
