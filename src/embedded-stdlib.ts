// Auto-generated file with embedded stdlib modules
// This file is generated by embed-stdlib.ts and should not be edited manually

export const embeddedStdlib = {
  "ai/ollama.js": "// Ollama module - Complete mirror of Ollama API\n// https://github.com/ollama/ollama/blob/main/docs/api.md\n\nconst OLLAMA_HOST = Deno.env.get(\"OLLAMA_HOST\") || \"http://localhost:11434\";\n\n// Helper for streaming responses\nasync function* streamResponse(response) {\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n  \n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    \n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() || \"\";\n    \n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          yield JSON.parse(line);\n        } catch (e) {\n          console.error(\"Failed to parse:\", line);\n        }\n      }\n    }\n  }\n}\n\n// Generate a completion\nexport async function generate(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/generate`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    const error = await response.text();\n    let message = `Ollama generate failed: ${response.statusText}`;\n    try {\n      const parsed = JSON.parse(error);\n      if (parsed.error) message = parsed.error;\n    } catch {}\n    throw new Error(message);\n  }\n  \n  if (request.stream === false) {\n    return await response.json();\n  }\n  \n  // Return async generator for streaming\n  return streamResponse(response);\n}\n\n// Chat completion\nexport async function chat(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/chat`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama chat failed: ${response.statusText}`);\n  }\n  \n  if (request.stream === false) {\n    return await response.json();\n  }\n  \n  return streamResponse(response);\n}\n\n// Create a model from a Modelfile\nexport async function create(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/create`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama create failed: ${response.statusText}`);\n  }\n  \n  if (request.stream === false) {\n    return await response.json();\n  }\n  \n  return streamResponse(response);\n}\n\n// List local models\nexport async function list() {\n  const response = await fetch(`${OLLAMA_HOST}/api/tags`);\n  \n  if (!response.ok) {\n    throw new Error(`Ollama list failed: ${response.statusText}`);\n  }\n  \n  return await response.json();\n}\n\n// Show model information\nexport async function show(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/show`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama show failed: ${response.statusText}`);\n  }\n  \n  return await response.json();\n}\n\n// Copy a model\nexport async function copy(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/copy`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama copy failed: ${response.statusText}`);\n  }\n  \n  return response.ok;\n}\n\n// Delete a model\nexport async function deleteModel(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/delete`, {\n    method: \"DELETE\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama delete failed: ${response.statusText}`);\n  }\n  \n  return response.ok;\n}\n\n// Pull a model\nexport async function pull(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/pull`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama pull failed: ${response.statusText}`);\n  }\n  \n  if (request.stream === false) {\n    return await response.json();\n  }\n  \n  return streamResponse(response);\n}\n\n// Push a model\nexport async function push(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/push`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama push failed: ${response.statusText}`);\n  }\n  \n  if (request.stream === false) {\n    return await response.json();\n  }\n  \n  return streamResponse(response);\n}\n\n// Generate embeddings\nexport async function embeddings(request) {\n  const response = await fetch(`${OLLAMA_HOST}/api/embeddings`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(request)\n  });\n  \n  if (!response.ok) {\n    throw new Error(`Ollama embeddings failed: ${response.statusText}`);\n  }\n  \n  return await response.json();\n}\n\n// List running models\nexport async function ps() {\n  const response = await fetch(`${OLLAMA_HOST}/api/ps`);\n  \n  if (!response.ok) {\n    throw new Error(`Ollama ps failed: ${response.statusText}`);\n  }\n  \n  return await response.json();\n}\n\n// Check if Ollama is running\nexport async function isRunning() {\n  try {\n    const response = await fetch(`${OLLAMA_HOST}/api/tags`);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}",
  "computer/context.js": "// Context Module - Captures current system state for developer productivity\n// Provides easy access to clipboard, selection, and screen content\n\nimport * as clipboardModule from \"../io/clipboard.js\";\nimport * as screenModule from \"./screen.js\";\nimport * as system from \"../core/system.js\";\n\n// Helper to get selected text\n// Uses multiple strategies depending on platform\nasync function getSelectedText() {\n  try {\n    // Strategy 1: Try to get selection via OS commands\n    if (Deno.build.os === \"darwin\") {\n      // On macOS, try using osascript to get selection from frontmost app\n      try {\n        const result = await system.exec(\n          `osascript -e 'tell application \"System Events\" to keystroke \"c\" using command down' && pbpaste`\n        );\n        if (result.success && result.stdout.trim()) {\n          return result.stdout.trim();\n        }\n      } catch {\n        // Fall through to next strategy\n      }\n    } else if (Deno.build.os === \"linux\") {\n      // On Linux, try xclip or xsel for primary selection\n      try {\n        const result = await system.exec(\"xclip -o -selection primary 2>/dev/null || xsel -o -p 2>/dev/null\");\n        if (result.success && result.stdout.trim()) {\n          return result.stdout.trim();\n        }\n      } catch {\n        // Fall through to next strategy\n      }\n    } else if (Deno.build.os === \"windows\") {\n      // On Windows, selection is harder to get directly\n      // Fall through to clipboard strategy\n    }\n    \n    // Strategy 2: Return null if no selection available\n    // This is better than returning stale clipboard data\n    return null;\n  } catch (error) {\n    console.error(\"Failed to get selection:\", error.message);\n    return null;\n  }\n}\n\n// Extract text from image using OCR\n// This is a placeholder - real implementation would use Vision framework on macOS,\n// Tesseract on Linux, or Windows OCR APIs\nasync function extractTextFromImage(imageData) {\n  try {\n    if (Deno.build.os === \"darwin\") {\n      // Save image temporarily and use macOS Vision framework via shortcuts or swift\n      const tempPath = `/tmp/hlvm_ocr_${Date.now()}.png`;\n      await Deno.writeFile(tempPath, imageData);\n      \n      // Try using shortcuts cli if available\n      const result = await system.exec(\n        `shortcuts run \"Extract Text from Image\" -i \"${tempPath}\" 2>/dev/null || echo \"\"`\n      );\n      \n      // Clean up temp file\n      try { await Deno.remove(tempPath); } catch {}\n      \n      if (result.success && result.stdout.trim()) {\n        return result.stdout.trim();\n      }\n    }\n    \n    // For now, return placeholder for other platforms\n    // Real implementation would integrate with Tesseract or other OCR\n    return \"[OCR not available on this platform yet]\";\n  } catch (error) {\n    console.error(\"OCR failed:\", error.message);\n    return \"\";\n  }\n}\n\n// Context namespace - provides current state\nexport const context = {\n  // Get currently selected text\n  get selection() {\n    // This is synchronous but internally uses cached async result\n    // For now, we'll make it async and users need to await\n    console.warn(\"Note: context.selection requires await\");\n    return getSelectedText();\n  },\n  \n  // Screen context object\n  screen: {\n    // Get current screen as image data - SYNCHRONOUS\n    get image() {\n      try {\n        // Capture to temp file and read as bytes\n        const tempPath = `/tmp/hlvm_screen_${Date.now()}.png`;\n        \n        // Use screencapture command directly for sync operation\n        if (Deno.build.os === \"darwin\") {\n          const p = new Deno.Command(\"screencapture\", {\n            args: [\"-x\", \"-C\", tempPath] // -x: no sound, -C: capture cursor\n          });\n          const output = p.outputSync();\n          if (!output.success) {\n            throw new Error(\"Screen capture failed\");\n          }\n        } else if (Deno.build.os === \"linux\") {\n          // Try various Linux screenshot tools\n          const tools = [\n            { cmd: \"import\", args: [\"-window\", \"root\", tempPath] }, // ImageMagick\n            { cmd: \"scrot\", args: [tempPath] },\n            { cmd: \"gnome-screenshot\", args: [\"-f\", tempPath] }\n          ];\n          \n          let captured = false;\n          for (const tool of tools) {\n            try {\n              const p = new Deno.Command(tool.cmd, { args: tool.args });\n              const output = p.outputSync();\n              if (output.success) {\n                captured = true;\n                break;\n              }\n            } catch {\n              // Try next tool\n            }\n          }\n          \n          if (!captured) {\n            throw new Error(\"No screenshot tool available\");\n          }\n        } else if (Deno.build.os === \"windows\") {\n          // Windows: Use PowerShell screenshot\n          const script = `\n            Add-Type -AssemblyName System.Windows.Forms\n            Add-Type -AssemblyName System.Drawing\n            $screen = [System.Windows.Forms.SystemInformation]::VirtualScreen\n            $bitmap = New-Object System.Drawing.Bitmap $screen.Width, $screen.Height\n            $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n            $graphics.CopyFromScreen($screen.Left, $screen.Top, 0, 0, $bitmap.Size)\n            $bitmap.Save('${tempPath}')\n          `;\n          const p = new Deno.Command(\"powershell\", {\n            args: [\"-NoProfile\", \"-Command\", script]\n          });\n          const output = p.outputSync();\n          if (!output.success) {\n            throw new Error(\"Screen capture failed\");\n          }\n        }\n        \n        // Read the captured image\n        const imageData = Deno.readFileSync(tempPath);\n        \n        // Clean up temp file\n        try { Deno.removeSync(tempPath); } catch {}\n        \n        return imageData;\n      } catch (error) {\n        console.error(\"Failed to capture screen:\", error.message);\n        return new Uint8Array();\n      }\n    },\n    \n    // Get text from current screen via OCR\n    get text() {\n      try {\n        // Get screen image first\n        const imageData = this.image;\n        if (imageData.length === 0) return \"\";\n        \n        // Extract text via OCR (this would be async in real implementation)\n        // For now return a sync placeholder\n        console.warn(\"Note: OCR is experimental and requires platform support\");\n        return \"[Screen text extraction pending implementation]\";\n      } catch (error) {\n        console.error(\"Failed to extract screen text:\", error.message);\n        return \"\";\n      }\n    }\n  }\n};\n\n// Make selection truly async since it needs to run commands\nObject.defineProperty(context, 'selection', {\n  get() {\n    return getSelectedText();\n  },\n  enumerable: true,\n  configurable: false\n});\n\n// Re-export for convenience\nexport default context;",
  "computer/keyboard.js": "// Keyboard module - Cross-platform keyboard automation\n\nimport * as platform from \"../core/platform.js\";\nimport { escapeKeyboard, powershell, linuxTool, PS, ERRORS } from \"../core/platform.js\";\n\nexport async function type(text) {\n  const escapedText = escapeKeyboard(text);\n  \n  if (platform.isDarwin) {\n    // macOS: osascript (built-in)\n    const script = `tell application \"System Events\" to keystroke \"${escapedText}\"`;\n    await new Deno.Command(\"osascript\", { args: [\"-e\", script] }).output();\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell SendKeys (built-in)\n    const script = `\n      ${PS.forms}\n      [System.Windows.Forms.SendKeys]::SendWait(\"${escapedText}\")\n    `;\n    await powershell(script);\n    \n  } else {\n    // Linux: Try xdotool or ydotool\n    await linuxTool(\n      [\"type\", text], // xdotool args\n      [\"type\", text], // ydotool args\n      ERRORS.LINUX_TOOLS\n    );\n  }\n}\n\n// Key mappings for cross-platform support\nconst KEY_MAP = {\n  // Common keys\n  \"enter\": { \n    darwin: \"return\", \n    windows: \"{ENTER}\", \n    linux: \"Return\" \n  },\n  \"return\": { \n    darwin: \"return\", \n    windows: \"{ENTER}\", \n    linux: \"Return\" \n  },\n  \"tab\": { \n    darwin: \"tab\", \n    windows: \"{TAB}\", \n    linux: \"Tab\" \n  },\n  \"delete\": { \n    darwin: \"delete\", \n    windows: \"{DEL}\", \n    linux: \"Delete\" \n  },\n  \"backspace\": { \n    darwin: \"delete\", \n    windows: \"{BACKSPACE}\", \n    linux: \"BackSpace\" \n  },\n  \"escape\": { \n    darwin: \"escape\", \n    windows: \"{ESC}\", \n    linux: \"Escape\" \n  },\n  \"space\": { \n    darwin: \"space\", \n    windows: \" \", \n    linux: \"space\" \n  },\n  \"up\": { \n    darwin: \"up arrow\", \n    windows: \"{UP}\", \n    linux: \"Up\" \n  },\n  \"down\": { \n    darwin: \"down arrow\", \n    windows: \"{DOWN}\", \n    linux: \"Down\" \n  },\n  \"left\": { \n    darwin: \"left arrow\", \n    windows: \"{LEFT}\", \n    linux: \"Left\" \n  },\n  \"right\": { \n    darwin: \"right arrow\", \n    windows: \"{RIGHT}\", \n    linux: \"Right\" \n  },\n  \"home\": { \n    darwin: \"home\", \n    windows: \"{HOME}\", \n    linux: \"Home\" \n  },\n  \"end\": { \n    darwin: \"end\", \n    windows: \"{END}\", \n    linux: \"End\" \n  },\n  \"pageup\": { \n    darwin: \"page up\", \n    windows: \"{PGUP}\", \n    linux: \"Page_Up\" \n  },\n  \"pagedown\": { \n    darwin: \"page down\", \n    windows: \"{PGDN}\", \n    linux: \"Page_Down\" \n  }\n};\n\nexport async function press(key, modifiers = {}) {\n  // Normalize key name\n  const normalizedKey = key.toLowerCase();\n  const keyMapping = KEY_MAP[normalizedKey] || {\n    darwin: key,\n    windows: key,\n    linux: key\n  };\n  \n  if (platform.isDarwin) {\n    // macOS: osascript with modifiers\n    const mods = [];\n    if (modifiers.cmd || modifiers.command) mods.push(\"command down\");\n    if (modifiers.ctrl || modifiers.control) mods.push(\"control down\");\n    if (modifiers.alt || modifiers.option) mods.push(\"option down\");\n    if (modifiers.shift) mods.push(\"shift down\");\n    \n    const keyName = keyMapping.darwin;\n    const script = mods.length > 0\n      ? `tell application \"System Events\" to keystroke \"${keyName}\" using {${mods.join(\", \")}}`\n      : `tell application \"System Events\" to keystroke \"${keyName}\"`;\n    \n    await new Deno.Command(\"osascript\", { args: [\"-e\", script] }).output();\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell SendKeys with modifiers\n    let keys = \"\";\n    if (modifiers.ctrl || modifiers.control) keys += \"^\";\n    if (modifiers.alt) keys += \"%\";\n    if (modifiers.shift) keys += \"+\";\n    keys += keyMapping.windows;\n    \n    const script = `\n      ${PS.forms}\n      [System.Windows.Forms.SendKeys]::SendWait(\"${keys}\")\n    `;\n    await powershell(script);\n    \n  } else {\n    // Linux: xdotool or ydotool\n    const keys = [];\n    if (modifiers.ctrl || modifiers.control) keys.push(\"ctrl\");\n    if (modifiers.alt) keys.push(\"alt\");\n    if (modifiers.shift) keys.push(\"shift\");\n    if (modifiers.cmd || modifiers.command || modifiers.super) keys.push(\"super\");\n    keys.push(keyMapping.linux);\n    \n    await linuxTool(\n      [\"key\", keys.join(\"+\")], // xdotool args\n      [\"key\", ...keys], // ydotool args\n      ERRORS.LINUX_TOOLS\n    );\n  }\n}\n\n// Send keyboard shortcut (convenience function)\nexport async function shortcut(keys) {\n  // Parse shortcut like \"cmd+a\" or \"ctrl+shift+t\"\n  const parts = keys.toLowerCase().split(\"+\");\n  const modifiers = {};\n  let key = \"\";\n  \n  for (const part of parts) {\n    if ([\"cmd\", \"command\", \"ctrl\", \"control\", \"alt\", \"option\", \"shift\", \"super\"].includes(part)) {\n      if (part === \"cmd\" || part === \"command\") modifiers.cmd = true;\n      if (part === \"ctrl\" || part === \"control\") modifiers.ctrl = true;\n      if (part === \"alt\" || part === \"option\") modifiers.alt = true;\n      if (part === \"shift\") modifiers.shift = true;\n      if (part === \"super\") modifiers.super = true;\n    } else {\n      key = part;\n    }\n  }\n  \n  return press(key, modifiers);\n}",
  "computer/mouse.js": "// Mouse module - Cross-platform mouse automation\n\nimport { runPlatformCommand } from \"../core/command.js\";\nimport { PS } from \"../core/platform.js\";\n\nexport async function move(x, y) {\n  await runPlatformCommand({\n    mac: {\n      cmd: \"cliclick\",\n      args: [`m:${x},${y}`],\n      fallback: {\n        cmd: \"python3\",\n        args: [\"-c\", `\nimport Quartz\nQuartz.CGWarpMouseCursorPosition((${x}, ${y}))\n        `]\n      }\n    },\n    windows: {\n      script: `\n        ${PS.forms}\n        [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${x}, ${y})\n      `\n    },\n    linux: {\n      xdotool: [\"mousemove\", String(x), String(y)],\n      ydotool: [\"mousemove\", String(x), String(y)],\n      errorMsg: \"Mouse move failed. Install xdotool (X11) or ydotool (Wayland)\"\n    }\n  });\n}\n\nexport async function click(x = null, y = null, button = \"left\") {\n  // Move to position if specified\n  if (x !== null && y !== null) {\n    await move(x, y);\n  }\n  \n  const buttonMap = {\n    linux: { \"left\": \"1\", \"middle\": \"2\", \"right\": \"3\" },\n    mac: { \"left\": \"c\", \"right\": \"rc\", \"middle\": \"mc\" }\n  };\n  \n  await runPlatformCommand({\n    mac: {\n      cmd: \"cliclick\",\n      args: x !== null && y !== null \n        ? [`${buttonMap.mac[button]}:${x},${y}`]\n        : [buttonMap.mac[button]],\n      fallback: {\n        cmd: \"python3\",\n        args: [\"-c\", `\nimport Quartz\nimport time\n\n# Get current position if not specified\n${x === null ? `\npos = Quartz.NSEvent.mouseLocation()\nx, y = pos.x, pos.y\n` : `x, y = ${x}, ${y}`}\n\n# Create mouse events\nbutton_map = {\n  \"left\": Quartz.kCGMouseButtonLeft,\n  \"right\": Quartz.kCGMouseButtonRight,\n  \"middle\": Quartz.kCGMouseButtonCenter\n}\n\nevent_down = {\n  \"left\": Quartz.kCGEventLeftMouseDown,\n  \"right\": Quartz.kCGEventRightMouseDown,\n  \"middle\": Quartz.kCGEventOtherMouseDown\n}\n\nevent_up = {\n  \"left\": Quartz.kCGEventLeftMouseUp,\n  \"right\": Quartz.kCGEventRightMouseUp,\n  \"middle\": Quartz.kCGEventOtherMouseUp\n}\n\nbutton_type = button_map.get(\"${button}\", button_map[\"left\"])\ndown_type = event_down.get(\"${button}\", event_down[\"left\"])\nup_type = event_up.get(\"${button}\", event_up[\"left\"])\n\nevent = Quartz.CGEventCreateMouseEvent(None, down_type, (x, y), button_type)\nQuartz.CGEventPost(Quartz.kCGHIDEventTap, event)\n\nevent = Quartz.CGEventCreateMouseEvent(None, up_type, (x, y), button_type)\nQuartz.CGEventPost(Quartz.kCGHIDEventTap, event)\n        `]\n      }\n    },\n    windows: {\n      script: `\n        Add-Type @\"\n          using System;\n          using System.Runtime.InteropServices;\n          public class Mouse {\n            [DllImport(\"user32.dll\")]\n            public static extern void mouse_event(int dwFlags, int dx, int dy, int cButtons, int dwExtraInfo);\n          }\n\"@\n        \n        ${x !== null && y !== null ? `\n        ${PS.forms}\n        [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${x}, ${y})\n        ` : \"\"}\n        \n        $flags = @{\n          left = @{ down = 0x0002; up = 0x0004 }\n          right = @{ down = 0x0008; up = 0x0010 }\n          middle = @{ down = 0x0020; up = 0x0040 }\n        }\n        \n        $buttonFlags = $flags[\"${button}\"]\n        if (-not $buttonFlags) { $buttonFlags = $flags.left }\n        \n        [Mouse]::mouse_event($buttonFlags.down, 0, 0, 0, 0)\n        [Mouse]::mouse_event($buttonFlags.up, 0, 0, 0, 0)\n      `\n    },\n    linux: {\n      xdotool: x !== null && y !== null \n        ? [\"mousemove\", String(x), String(y), \"click\", buttonMap.linux[button] || \"1\"]\n        : [\"click\", buttonMap.linux[button] || \"1\"],\n      ydotool: x !== null && y !== null\n        ? [\"mousemove\", String(x), String(y), \"click\", buttonMap.linux[button] || \"1\"]\n        : [\"click\", buttonMap.linux[button] || \"1\"],\n      errorMsg: \"Mouse click failed. Install xdotool (X11) or ydotool (Wayland)\"\n    }\n  });\n}\n\nexport async function position() {\n  const result = await runPlatformCommand({\n    mac: {\n      cmd: \"cliclick\",\n      args: [\"p\"],\n      fallback: {\n        cmd: \"python3\",\n        args: [\"-c\", `\nimport Quartz\npos = Quartz.NSEvent.mouseLocation()\nprint(f\"{int(pos.x)},{int(pos.y)}\")\n        `]\n      }\n    },\n    windows: {\n      script: `\n        ${PS.forms}\n        $pos = [System.Windows.Forms.Cursor]::Position\n        Write-Host \"$($pos.X),$($pos.Y)\"\n      `\n    },\n    linux: {\n      cmd: \"xdotool\",\n      args: [\"getmouselocation\"],\n      fallback: [\n        { cmd: \"ydotool\", args: [\"mousemove\", \"--get\"] }\n      ],\n      errorMsg: \"Mouse position failed. Install xdotool (X11) or ydotool (Wayland)\"\n    }\n  });\n  \n  // Parse position from result\n  if (typeof result === 'string') {\n    const output = result.trim();\n    \n    // Linux xdotool format: \"x:123 y:456 ...\"\n    if (output.includes(\"x:\") && output.includes(\"y:\")) {\n      const x = parseInt(output.match(/x:(\\d+)/)?.[1] || \"0\");\n      const y = parseInt(output.match(/y:(\\d+)/)?.[1] || \"0\");\n      return { x, y };\n    }\n    \n    // Common format: \"123,456\"\n    if (output.includes(\",\")) {\n      const [x, y] = output.split(\",\").map(n => parseInt(n));\n      return { x, y };\n    }\n    \n    // ydotool format: \"123 456\"\n    const parts = output.split(\" \").map(n => parseInt(n));\n    if (parts.length >= 2) {\n      return { x: parts[0], y: parts[1] };\n    }\n  }\n  \n  throw new Error(\"Failed to get mouse position\");\n}\n\n// Double click\nexport async function doubleClick(x = null, y = null) {\n  await click(x, y);\n  await new Promise(r => setTimeout(r, 50)); // Small delay\n  await click(x, y);\n}\n\n// Drag from one position to another\nexport async function drag(fromX, fromY, toX, toY) {\n  await runPlatformCommand({\n    mac: {\n      cmd: \"cliclick\",\n      args: [`dd:${fromX},${fromY}`, `du:${toX},${toY}`],\n      fallback: async () => {\n        await move(fromX, fromY);\n        await click(fromX, fromY);\n        await move(toX, toY);\n        await click(toX, toY);\n      }\n    },\n    windows: {\n      script: `\n        Add-Type @\"\n          using System;\n          using System.Runtime.InteropServices;\n          public class Mouse {\n            [DllImport(\"user32.dll\")]\n            public static extern void mouse_event(int dwFlags, int dx, int dy, int cButtons, int dwExtraInfo);\n          }\n\"@\n        ${PS.forms}\n        \n        # Move to start position\n        [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${fromX}, ${fromY})\n        # Mouse down\n        [Mouse]::mouse_event(0x0002, 0, 0, 0, 0)\n        # Move to end position\n        [System.Windows.Forms.Cursor]::Position = New-Object System.Drawing.Point(${toX}, ${toY})\n        # Mouse up\n        [Mouse]::mouse_event(0x0004, 0, 0, 0, 0)\n      `\n    },\n    linux: {\n      xdotool: [\"mousemove\", String(fromX), String(fromY), \"mousedown\", \"1\",\n                \"mousemove\", String(toX), String(toY), \"mouseup\", \"1\"],\n      ydotool: [\"mousemove\", String(fromX), String(fromY), \"mousedown\", \"1\",\n                \"mousemove\", String(toX), String(toY), \"mouseup\", \"1\"],\n      fallback: async () => {\n        await move(fromX, fromY);\n        await click(fromX, fromY);\n        await move(toX, toY);\n        await click(toX, toY);\n      }\n    }\n  });\n}",
  "computer/notification.js": "// Notification module - Cross-platform UI dialogs and notifications\n\nimport * as platform from \"../core/platform.js\";\nimport { escapeShell, decode, powershell, PS, ERRORS } from \"../core/platform.js\";\n\nexport async function alert(message, title = \"Alert\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  \n  if (platform.isDarwin) {\n    // macOS: osascript (built-in)\n    const script = `display alert \"${escapedTitle}\" message \"${escapedMessage}\"`;\n    await new Deno.Command(\"osascript\", { args: [\"-e\", script] }).output();\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell MessageBox (built-in)\n    const script = `\n      ${PS.forms}\n      [System.Windows.Forms.MessageBox]::Show(\"${escapedMessage}\", \"${escapedTitle}\")\n    `;\n    await powershell(script);\n    \n  } else {\n    // Linux: Try multiple tools\n    try {\n      // Try zenity first (most common)\n      await new Deno.Command(\"zenity\", {\n        args: [\"--info\", \"--text\", message, \"--title\", title]\n      }).output();\n    } catch {\n      try {\n        // Fallback to kdialog (KDE)\n        await new Deno.Command(\"kdialog\", {\n          args: [\"--msgbox\", message, \"--title\", title]\n        }).output();\n      } catch {\n        // Last resort: notify-send (notification, not dialog)\n        await notify(message, title);\n      }\n    }\n  }\n}\n\nexport async function notify(message, title = \"Notification\", subtitle = \"\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  \n  if (platform.isDarwin) {\n    // macOS: osascript notification (built-in)\n    let script = `display notification \"${escapedMessage}\" with title \"${escapedTitle}\"`;\n    if (subtitle) {\n      script += ` subtitle \"${escapeShell(subtitle)}\"`;\n    }\n    await new Deno.Command(\"osascript\", { args: [\"-e\", script] }).output();\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell BurntToast or fallback to balloon tip\n    try {\n      // Try Windows 10+ toast notification\n      const script = `\n        [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null\n        [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null\n        \n        $template = @\"\n        <toast>\n          <visual>\n            <binding template=\"ToastGeneric\">\n              <text>${escapedTitle}</text>\n              <text>${escapedMessage}</text>\n            </binding>\n          </visual>\n        </toast>\n\"@\n        $xml = New-Object Windows.Data.Xml.Dom.XmlDocument\n        $xml.LoadXml($template)\n        $toast = New-Object Windows.UI.Notifications.ToastNotification $xml\n        [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier(\"HLVM\").Show($toast)\n      `;\n      await powershell(script);\n    } catch {\n      // Fallback to simple alert\n      await alert(message, title);\n    }\n    \n  } else {\n    // Linux: notify-send (most universal)\n    try {\n      await new Deno.Command(\"notify-send\", {\n        args: [title, message]\n      }).output();\n    } catch {\n      console.error(ERRORS.LINUX_NOTIFY);\n    }\n  }\n}\n\nexport async function confirm(message, title = \"Confirm\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  \n  if (platform.isDarwin) {\n    // macOS: osascript dialog (built-in)\n    const script = `\n      button returned of (display dialog \"${escapedMessage}\" ¬\n        with title \"${escapedTitle}\" ¬\n        buttons {\"Cancel\", \"OK\"} ¬\n        default button \"OK\")\n    `;\n    try {\n      const { stdout } = await new Deno.Command(\"osascript\", { \n        args: [\"-e\", script] \n      }).output();\n      return decode(stdout).trim() === \"OK\";\n    } catch {\n      return false; // User cancelled\n    }\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell YesNo MessageBox (built-in)\n    const script = `\n      ${PS.forms}\n      $result = [System.Windows.Forms.MessageBox]::Show(\n        \"${escapedMessage}\", \n        \"${escapedTitle}\", \n        [System.Windows.Forms.MessageBoxButtons]::YesNo\n      )\n      if ($result -eq [System.Windows.Forms.DialogResult]::Yes) {\n        Write-Host \"true\"\n      } else {\n        Write-Host \"false\"\n      }\n    `;\n    const { stdout } = await powershell(script);\n    return decode(stdout).trim() === \"true\";\n    \n  } else {\n    // Linux: Try zenity or kdialog\n    try {\n      const { code } = await new Deno.Command(\"zenity\", {\n        args: [\"--question\", \"--text\", message, \"--title\", title]\n      }).output();\n      return code === 0;\n    } catch {\n      try {\n        const { code } = await new Deno.Command(\"kdialog\", {\n          args: [\"--yesno\", message, \"--title\", title]\n        }).output();\n        return code === 0;\n      } catch {\n        console.error(ERRORS.LINUX_DIALOG);\n        return false;\n      }\n    }\n  }\n}\n\nexport async function prompt(message, defaultValue = \"\", title = \"Input\") {\n  const escapedMessage = escapeShell(message);\n  const escapedTitle = escapeShell(title);\n  const escapedDefault = escapeShell(defaultValue);\n  \n  if (platform.isDarwin) {\n    // macOS: osascript input dialog (built-in)\n    const script = `\n      text returned of (display dialog \"${escapedMessage}\" ¬\n        with title \"${escapedTitle}\" ¬\n        default answer \"${escapedDefault}\" ¬\n        buttons {\"Cancel\", \"OK\"} ¬\n        default button \"OK\")\n    `;\n    try {\n      const { stdout } = await new Deno.Command(\"osascript\", { \n        args: [\"-e\", script] \n      }).output();\n      return decode(stdout).trim();\n    } catch {\n      return null; // User cancelled\n    }\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell InputBox (built-in)\n    const script = `\n      ${PS.visualBasic}\n      $result = [Microsoft.VisualBasic.Interaction]::InputBox(\n        \"${escapedMessage}\", \n        \"${escapedTitle}\", \n        \"${escapedDefault}\"\n      )\n      if ($result -eq \"\") {\n        # Could be cancelled or empty input\n        if ($LastExitCode -eq 0) {\n          Write-Host \"\"\n        }\n      } else {\n        Write-Host $result\n      }\n    `;\n    const { stdout } = await powershell(script);\n    return decode(stdout).trim();\n    \n  } else {\n    // Linux: Try zenity or kdialog\n    try {\n      const args = [\"zenity\", \"--entry\", \"--text\", message, \"--title\", title];\n      if (defaultValue) args.push(\"--entry-text\", defaultValue);\n      const { stdout, code } = await new Deno.Command(args[0], {\n        args: args.slice(1)\n      }).output();\n      return code === 0 ? decode(stdout).trim() : null;\n    } catch {\n      try {\n        const { stdout, code } = await new Deno.Command(\"kdialog\", {\n          args: [\"--inputbox\", message, defaultValue, \"--title\", title]\n        }).output();\n        return code === 0 ? decode(stdout).trim() : null;\n      } catch {\n        console.error(ERRORS.LINUX_DIALOG);\n        return null;\n      }\n    }\n  }\n}",
  "computer/screen.js": "// Screen module - Cross-platform screen capture\n\nimport * as platform from \"../core/platform.js\";\n\nexport async function capture(output = null, options = {}) {\n  // Use platform-specific temp file if no output specified\n  if (!output) {\n    const tempDir = platform.tempDir();\n    const timestamp = Date.now();\n    output = `${tempDir}${platform.pathSep}screenshot-${timestamp}.png`;\n  }\n  \n  if (platform.isDarwin) {\n    // macOS: screencapture (built-in)\n    const args = [\"-x\"]; // No sound\n    \n    if (options.interactive) {\n      args.push(\"-i\"); // Interactive mode (user selects window)\n    }\n    if (options.selection || options.select) {\n      args.push(\"-s\"); // Selection mode (user draws rectangle)\n    }\n    if (options.window) {\n      args.push(\"-w\"); // Window selection mode\n    }\n    if (options.delay) {\n      args.push(\"-T\", String(options.delay)); // Delay in seconds\n    }\n    \n    args.push(output);\n    \n    const { success } = await new Deno.Command(\"screencapture\", { args }).output();\n    if (!success) throw new Error(\"Screenshot failed\");\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell screenshot (built-in)\n    const script = `\n      Add-Type -AssemblyName System.Windows.Forms\n      Add-Type -AssemblyName System.Drawing\n      \n      $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n      $bounds = $screen.Bounds\n      $bitmap = New-Object System.Drawing.Bitmap($bounds.Width, $bounds.Height)\n      $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n      $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)\n      $bitmap.Save(\"${output.replace(/\\\\/g, '\\\\\\\\')}\")\n      $graphics.Dispose()\n      $bitmap.Dispose()\n    `;\n    \n    const { success } = await new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", script]\n    }).output();\n    if (!success) throw new Error(\"Screenshot failed\");\n    \n  } else {\n    // Linux: Try multiple screenshot tools\n    const tools = [\n      {\n        cmd: \"scrot\",\n        args: options.selection ? [\"-s\", output] : [output]\n      },\n      {\n        cmd: \"gnome-screenshot\",\n        args: options.selection \n          ? [\"-a\", \"-f\", output]\n          : [\"-f\", output]\n      },\n      {\n        cmd: \"spectacle\",\n        args: options.selection\n          ? [\"-r\", \"-b\", \"-n\", \"-o\", output]\n          : [\"-b\", \"-n\", \"-o\", output]\n      },\n      {\n        cmd: \"import\", // ImageMagick\n        args: [output]\n      }\n    ];\n    \n    let captured = false;\n    for (const tool of tools) {\n      try {\n        const { success } = await new Deno.Command(tool.cmd, {\n          args: tool.args\n        }).output();\n        if (success) {\n          captured = true;\n          break;\n        }\n      } catch {\n        // Try next tool\n      }\n    }\n    \n    if (!captured) {\n      throw new Error(\n        \"Screenshot failed. Install one of: scrot, gnome-screenshot, spectacle, or imagemagick\"\n      );\n    }\n  }\n  \n  return output;\n}\n\n// Get screen dimensions (cross-platform)\nexport async function getScreenSize() {\n  if (platform.isDarwin) {\n    // macOS: Use system_profiler\n    const { stdout } = await new Deno.Command(\"system_profiler\", {\n      args: [\"SPDisplaysDataType\", \"-json\"]\n    }).output();\n    \n    try {\n      const data = JSON.parse(new TextDecoder().decode(stdout));\n      const display = data.SPDisplaysDataType[0].spdisplays_ndrvs[0];\n      const resolution = display._spdisplays_resolution.match(/(\\d+) x (\\d+)/);\n      if (resolution) {\n        return {\n          width: parseInt(resolution[1]),\n          height: parseInt(resolution[2])\n        };\n      }\n    } catch {}\n    \n  } else if (platform.isWindows) {\n    // Windows: Use PowerShell\n    const script = `\n      Add-Type -AssemblyName System.Windows.Forms\n      $screen = [System.Windows.Forms.Screen]::PrimaryScreen\n      Write-Host \"$($screen.Bounds.Width),$($screen.Bounds.Height)\"\n    `;\n    \n    const { stdout } = await new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", script]\n    }).output();\n    \n    const [width, height] = new TextDecoder().decode(stdout).trim().split(\",\");\n    return {\n      width: parseInt(width),\n      height: parseInt(height)\n    };\n    \n  } else {\n    // Linux: Try xrandr or xdpyinfo\n    try {\n      const { stdout } = await new Deno.Command(\"xrandr\", {\n        args: [\"--current\"]\n      }).output();\n      \n      const output = new TextDecoder().decode(stdout);\n      const match = output.match(/primary (\\d+)x(\\d+)/);\n      if (match) {\n        return {\n          width: parseInt(match[1]),\n          height: parseInt(match[2])\n        };\n      }\n    } catch {\n      try {\n        const { stdout } = await new Deno.Command(\"xdpyinfo\").output();\n        const output = new TextDecoder().decode(stdout);\n        const match = output.match(/dimensions:\\s+(\\d+)x(\\d+)/);\n        if (match) {\n          return {\n            width: parseInt(match[1]),\n            height: parseInt(match[2])\n          };\n        }\n      } catch {}\n    }\n  }\n  \n  // Fallback\n  return { width: 1920, height: 1080 };\n}",
  "core/command.js": "// Unified cross-platform command execution\n// Eliminates duplicate platform detection across modules\n\nimport { isDarwin, isWindows, isLinux, decode, powershell, linuxTool } from \"./platform.js\";\n\n/**\n * Execute platform-specific commands with automatic OS detection\n * @param {Object} commands - Object with mac, windows, linux command configs\n * @returns {Promise<any>} Command output\n */\nexport async function runPlatformCommand(commands) {\n  if (isDarwin && commands.mac) {\n    return await runMacCommand(commands.mac);\n  } else if (isWindows && commands.windows) {\n    return await runWindowsCommand(commands.windows);\n  } else if (isLinux && commands.linux) {\n    return await runLinuxCommand(commands.linux);\n  }\n  throw new Error(`Unsupported platform or missing command configuration`);\n}\n\nasync function runMacCommand(config) {\n  const { cmd = \"osascript\", args = [], script, fallback } = config;\n  \n  try {\n    if (script) {\n      const result = await new Deno.Command(cmd, {\n        args: [...args, \"-e\", script]\n      }).output();\n      \n      if (config.decode !== false) {\n        return decode(result.stdout);\n      }\n      return result;\n    }\n    \n    const result = await new Deno.Command(cmd, { args }).output();\n    if (!result.success && fallback) {\n      throw new Error(\"Primary command failed\");\n    }\n    \n    if (config.decode !== false && result.stdout) {\n      return decode(result.stdout);\n    }\n    return result;\n  } catch (error) {\n    if (fallback) {\n      // Handle fallback - can be a function or command config\n      if (typeof fallback === 'function') {\n        return await fallback();\n      }\n      return await runMacCommand(fallback);\n    }\n    throw error;\n  }\n}\n\nasync function runWindowsCommand(config) {\n  const { script, decode: shouldDecode = true } = config;\n  \n  if (script) {\n    const result = await powershell(script);\n    if (shouldDecode) {\n      return decode(result.stdout);\n    }\n    return result;\n  }\n  \n  throw new Error(\"Windows command requires a script\");\n}\n\nasync function runLinuxCommand(config) {\n  const { xdotool, ydotool, fallback, errorMsg, cmd, args } = config;\n  \n  // Use specific command if provided\n  if (cmd) {\n    try {\n      const result = await new Deno.Command(cmd, { args: args || [] }).output();\n      if (!result.success && fallback) {\n        throw new Error(\"Primary command failed\");\n      }\n      if (config.decode !== false) {\n        return decode(result.stdout);\n      }\n      return result;\n    } catch (error) {\n      if (fallback) {\n        // Handle fallback - can be function, array, or single command\n        if (typeof fallback === 'function') {\n          return await fallback();\n        }\n        if (Array.isArray(fallback)) {\n          for (const fb of fallback) {\n            try {\n              const result = await new Deno.Command(fb.cmd, { args: fb.args }).output();\n              if (config.decode !== false) {\n                return decode(result.stdout);\n              }\n              return result;\n            } catch {\n              continue;\n            }\n          }\n          throw new Error(errorMsg || \"No Linux command available\");\n        }\n        // Single fallback command\n        return await runLinuxCommand(fallback);\n      }\n      throw error;\n    }\n  }\n  \n  // Use xdotool/ydotool fallback pattern\n  if (xdotool && ydotool) {\n    const result = await linuxTool(xdotool, ydotool, errorMsg);\n    if (config.decode !== false) {\n      return decode(result.stdout);\n    }\n    return result;\n  }\n  \n  // Use fallback if no primary command\n  if (fallback) {\n    if (typeof fallback === 'function') {\n      return await fallback();\n    }\n    if (Array.isArray(fallback)) {\n      for (const fb of fallback) {\n        try {\n          const result = await new Deno.Command(fb.cmd, { args: fb.args }).output();\n          if (config.decode !== false) {\n            return decode(result.stdout);\n          }\n          return result;\n        } catch {\n          continue;\n        }\n      }\n    }\n    throw new Error(errorMsg || \"No Linux command available\");\n  }\n  \n  throw new Error(\"Linux command configuration required\");\n}\n\n/**\n * Simple command runner that returns decoded text by default\n */\nexport async function runCommand(cmd, args = []) {\n  const result = await new Deno.Command(cmd, { args }).output();\n  return decode(result.stdout);\n}\n\n/**\n * Check if a command exists on the system\n */\nexport async function commandExists(cmd) {\n  try {\n    const checkCmd = isWindows ? \"where\" : \"which\";\n    await new Deno.Command(checkCmd, { args: [cmd] }).output();\n    return true;\n  } catch {\n    return false;\n  }\n}",
  "core/database.js": "// Database module - Cross-platform SQLite persistence\n\nimport { DatabaseSync } from \"node:sqlite\";  // Works in compiled binaries!\nimport * as platform from \"./platform.js\";\nimport { notifyModulesChanged, notifyEvent } from \"./notifier.js\";\n\n// Try to load esbuild if available\nlet esbuild = null;\ntry {\n  esbuild = await import(\"https://deno.land/x/esbuild@0.20.0/mod.js\");\n} catch {\n  // esbuild not available - bundling will be disabled\n}\n\n// Get cross-platform database path\nfunction dbPath() {\n  if (platform.isDarwin) {\n    // macOS: ~/Library/Application Support/HLVM/\n    return `${platform.homeDir()}/Library/Application Support/HLVM/HLVM.sqlite`;\n  } else if (platform.isWindows) {\n    // Windows: %APPDATA%\\HLVM\\\n    const appData = Deno.env.get(\"APPDATA\") || \n                    `${platform.homeDir()}\\\\AppData\\\\Roaming`;\n    return `${appData}\\\\HLVM\\\\HLVM.sqlite`;\n  } else {\n    // Linux/Unix: ~/.local/share/HLVM/\n    const xdgData = Deno.env.get(\"XDG_DATA_HOME\") || \n                    `${platform.homeDir()}/.local/share`;\n    return `${xdgData}/HLVM/HLVM.sqlite`;\n  }\n}\n\nexport const path = dbPath();\n\n// Extract directory with cross-platform support\nconst dbDir = path.substring(0, \n  path.lastIndexOf(platform.isWindows ? \"\\\\\" : \"/\")\n);\n\n// Ensure directory exists\nawait Deno.mkdir(dbDir, { recursive: true });\n\n// Open database\nexport const db = new DatabaseSync(path);\n\n// Create modules directory if it doesn't exist\nconst modulesDir = `${dbDir}${platform.pathSep}modules`;\nawait Deno.mkdir(modulesDir, { recursive: true });\n\n// Create table with WAL mode for better concurrency\ndb.exec(\"PRAGMA journal_mode=WAL\");\n\n// Check if we need to migrate from old schema\nconst tableInfo = db.prepare(\"PRAGMA table_info(modules)\").all();\nconst hasSourceCode = tableInfo.some(col => col.name === 'source_code');\nconst hasFilePath = tableInfo.some(col => col.name === 'file_path');\n\nif (hasSourceCode && !hasFilePath) {\n  // Old schema - needs migration\n  console.log(\"Migrating HLVM database to new schema...\");\n  \n  // Create new table with new schema\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS modules_new (\n      key TEXT PRIMARY KEY,\n      namespace TEXT NOT NULL,\n      file_path TEXT NOT NULL,\n      entry_point TEXT DEFAULT 'default',\n      metadata TEXT DEFAULT '{}',\n      type TEXT DEFAULT 'javascript',\n      updated_at INTEGER NOT NULL,\n      spotlight BOOLEAN DEFAULT 1\n    )\n  `);\n  \n  // Migrate existing data (save source_code to files)\n  const oldModules = db.prepare(\"SELECT * FROM modules\").all();\n  for (const mod of oldModules) {\n    const fileName = `${mod.key}.module.js`;\n    const filePath = `${modulesDir}${platform.pathSep}${fileName}`;\n    await Deno.writeTextFile(filePath, mod.source_code);\n    \n    db.prepare(`\n      INSERT INTO modules_new (key, namespace, file_path, entry_point, metadata, type, updated_at, spotlight)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `).run(mod.key, mod.namespace, `modules/${fileName}`, 'default', mod.metadata, mod.type, mod.updated_at, mod.spotlight);\n  }\n  \n  // Drop old table and rename new one\n  db.exec(\"DROP TABLE modules\");\n  db.exec(\"ALTER TABLE modules_new RENAME TO modules\");\n  \n  console.log(\"Migration complete!\");\n} else if (!hasSourceCode && !hasFilePath) {\n  // No table or empty - create new schema\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS modules (\n      key TEXT PRIMARY KEY,\n      namespace TEXT NOT NULL,\n      file_path TEXT NOT NULL,\n      entry_point TEXT DEFAULT 'default',\n      metadata TEXT DEFAULT '{}',\n      type TEXT DEFAULT 'javascript',\n      updated_at INTEGER NOT NULL,\n      spotlight BOOLEAN DEFAULT 1\n    )\n  `);\n}\n\n// Detect if input is a file path more elegantly\nfunction isFilePath(input) {\n  try {\n    // Check if it's an existing file\n    const stat = Deno.statSync(input);\n    return stat.isFile;\n  } catch {\n    // Not an existing file, check if it looks like a path\n    return input.includes('/') || input.endsWith('.js') || input.endsWith('.ts');\n  }\n}\n\n// Bundle code using esbuild (required)\nasync function bundleCode(codeOrPath) {\n  // If esbuild not available, just return the code as-is for now (temporary for testing)\n  if (!esbuild) {\n    // For testing in compiled binary - just return code without bundling\n    const isPath = isFilePath(codeOrPath);\n    if (isPath) {\n      return await Deno.readTextFile(codeOrPath);\n    }\n    return typeof codeOrPath === 'function' \n      ? `export default ${codeOrPath.toString()}`\n      : codeOrPath;\n  }\n  \n  const isPath = isFilePath(codeOrPath);\n  \n  try {\n    const result = await esbuild.build({\n      entryPoints: isPath ? [codeOrPath] : undefined,\n      stdin: !isPath ? {\n        contents: typeof codeOrPath === 'function' \n          ? `export default ${codeOrPath.toString()}`\n          : codeOrPath,\n        loader: 'js',\n        resolveDir: Deno.cwd(),\n      } : undefined,\n      bundle: true,\n      format: 'esm',\n      platform: 'browser',  // Use 'browser' for Deno compatibility\n      target: 'esnext',\n      write: false,\n    });\n    \n    if (result.errors.length > 0) {\n      const error = result.errors[0];\n      throw new Error(`${error.text} at ${error.location?.file || 'input'}:${error.location?.line || 0}`);\n    }\n    \n    // Stop esbuild to free resources\n    await esbuild.stop();\n    \n    return result.outputFiles[0].text;\n  } catch (error) {\n    // Determine error type for better reporting\n    let errorType = 'bundle';\n    if (error.message.includes('Could not resolve')) {\n      errorType = 'import';\n    } else if (error.message.includes('Syntax') || error.message.includes('Unexpected')) {\n      errorType = 'syntax';\n    }\n    \n    // Re-throw with type\n    error.type = errorType;\n    throw error;\n  }\n}\n\nexport async function save(name, codeOrPath) {\n  try {\n    // Bundle the code\n    const bundled = await bundleCode(codeOrPath);\n    \n    // Detect if it has default export function\n    const hasDefaultFunction = bundled.includes('export default function') ||\n                              bundled.includes('export default async function');\n    \n    // Save bundled code to file\n    const fileName = `${name}.module.js`;\n    const filePath = `${modulesDir}${platform.pathSep}${fileName}`;\n    await Deno.writeTextFile(filePath, bundled);\n    \n    // Save metadata to SQLite\n    const namespace = `hlvm.${name}`;\n    const metadata = JSON.stringify({\n      hasDefaultFunction,\n      createdAt: new Date().toISOString(),\n      platform: platform.os,\n      bundled: true,\n      isUserModule: true\n    });\n    \n    const stmt = db.prepare(`\n      INSERT OR REPLACE INTO modules \n      (key, namespace, file_path, entry_point, metadata, type, updated_at, spotlight)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n    \n    const entryPoint = hasDefaultFunction ? 'default' : 'script';\n    stmt.run(name, namespace, `modules/${fileName}`, entryPoint, metadata, 'javascript', Date.now(), 1);\n    \n    // Notify system about the change (cross-platform)\n    await notifyModulesChanged();\n    \n    return true;\n  } catch (error) {\n    // Notify system about bundle failure\n    const errorInfo = {\n      name,\n      error: error.message,\n      type: error.type || 'unknown'\n    };\n    \n    // Log error for user (DRY - single source of error message)\n    console.error(`❌ Failed to save '${name}': ${error.message}`);\n    \n    // Notify GUI apps\n    await notifyEvent('module.bundle.failed', errorInfo);\n    \n    throw error;\n  }\n}\n\nexport async function load(name) {\n  try {\n    const module = db.prepare(\"SELECT * FROM modules WHERE key = ?\").get(name);\n    if (!module) throw new Error(`Module '${name}' not found`);\n    \n    // Read code from file\n    const filePath = `${dbDir}${platform.pathSep}${module.file_path}`;\n    const code = await Deno.readTextFile(filePath);\n    \n    // Create temp file for import\n    const tempDir = platform.tempDir();\n    const tempFile = `${tempDir}${platform.pathSep}hlvm-module-${name}-${Date.now()}.js`;\n    await Deno.writeTextFile(tempFile, code);\n    \n    // Import with file:// protocol\n    const imported = await import(`file://${tempFile}`);\n    \n    // Clean up after import\n    setTimeout(() => Deno.remove(tempFile).catch(() => {}), 1000);\n    \n    // Return the default function directly if it exists, otherwise return the module\n    // This makes it more intuitive: const fn = await load('name'); await fn();\n    return imported.default || imported;\n  } catch (e) {\n    throw new Error(`Load failed: ${e.message}`);\n  }\n}\n\n// Get source code for editing/viewing\nexport async function getSource(name) {\n  try {\n    const module = db.prepare(\"SELECT * FROM modules WHERE key = ?\").get(name);\n    if (!module) throw new Error(`Module '${name}' not found`);\n    \n    // Read code from file\n    const filePath = `${dbDir}${platform.pathSep}${module.file_path}`;\n    const code = await Deno.readTextFile(filePath);\n    \n    return code;\n  } catch (e) {\n    throw new Error(`Get source failed: ${e.message}`);\n  }\n}\n\nexport function list() {\n  try {\n    const stmt = db.prepare(`\n      SELECT key, namespace, file_path, entry_point, type, updated_at, spotlight \n      FROM modules \n      WHERE spotlight = 1 \n      ORDER BY updated_at DESC\n    `);\n    const modules = stmt.all();\n    return modules.map(m => ({\n      key: m.key,\n      namespace: m.namespace,\n      filePath: m.file_path,\n      entryPoint: m.entry_point,\n      type: m.type,\n      updatedAt: new Date(m.updated_at)\n    }));\n  } catch (e) {\n    return [];\n  }\n}\n\nexport async function remove(name) {\n  try {\n    // Get module info first\n    const module = db.prepare(\"SELECT file_path FROM modules WHERE key = ?\").get(name);\n    \n    if (module) {\n      // Delete the file\n      const filePath = `${dbDir}${platform.pathSep}${module.file_path}`;\n      await Deno.remove(filePath).catch(() => {});\n    }\n    \n    // Delete from database\n    const stmt = db.prepare(\"DELETE FROM modules WHERE key = ?\");\n    stmt.run(name);\n    \n    // Notify system about the change (cross-platform)\n    await notifyModulesChanged();\n    \n    return true;\n  } catch (e) {\n    throw new Error(`Remove failed: ${e.message}`);\n  }\n}",
  "core/notifier.js": "// Cross-platform system notification module\n// Notifies other processes about HLVM changes\n\nimport * as platform from \"./platform.js\";\n\n/**\n * Notify system-wide that HLVM modules have changed\n * This allows GUI apps to refresh their module lists in real-time\n */\nexport async function notifyModulesChanged() {\n  try {\n    if (platform.isDarwin) {\n      // macOS: Use Darwin distributed notifications via Swift\n      const cmd = new Deno.Command(\"swift\", {\n        args: [\"-e\", `\n          import Foundation\n          CFNotificationCenterPostNotification(\n            CFNotificationCenterGetDarwinNotifyCenter(),\n            CFNotificationName(\"com.hlvm.modules.changed\" as CFString),\n            nil,\n            nil,\n            true\n          )\n        `],\n        stdout: \"null\",\n        stderr: \"null\"\n      });\n      await cmd.output();\n      console.log(\"📢 Notified system: modules changed\");\n      return true;\n      \n    } else if (platform.isWindows) {\n      // Windows: Could use named pipes or registry events\n      // For now, just log\n      console.log(\"📢 Windows notification not implemented yet\");\n      return false;\n      \n    } else if (platform.isLinux) {\n      // Linux: Could use D-Bus notifications\n      try {\n        const cmd = new Deno.Command(\"dbus-send\", {\n          args: [\n            \"--system\",\n            \"--type=signal\",\n            \"/com/hlvm/modules\",\n            \"com.hlvm.modules.Changed\"\n          ],\n          stdout: \"null\",\n          stderr: \"null\"\n        });\n        await cmd.output();\n        console.log(\"📢 Notified system via D-Bus: modules changed\");\n        return true;\n      } catch {\n        console.log(\"📢 Linux notification failed (D-Bus not available)\");\n        return false;\n      }\n      \n    } else {\n      console.log(\"📢 Platform notification not supported\");\n      return false;\n    }\n  } catch (error) {\n    console.error(\"Failed to send system notification:\", error.message);\n    return false;\n  }\n}\n\n/**\n * Notify system about a specific event\n * @param {string} event - Event name (e.g., \"module.saved\", \"module.removed\")\n * @param {object} data - Optional event data\n */\nexport async function notifyEvent(event, data = null) {\n  try {\n    if (platform.isDarwin) {\n      // macOS: Send event-specific notification\n      const notificationName = `com.hlvm.${event}`;\n      const cmd = new Deno.Command(\"swift\", {\n        args: [\"-e\", `\n          import Foundation\n          CFNotificationCenterPostNotification(\n            CFNotificationCenterGetDarwinNotifyCenter(),\n            CFNotificationName(\"${notificationName}\" as CFString),\n            nil,\n            ${data ? `[\"data\": \"${JSON.stringify(data).replace(/\"/g, '\\\\\"')}\"] as CFDictionary` : 'nil'},\n            true\n          )\n        `],\n        stdout: \"null\",\n        stderr: \"null\"\n      });\n      await cmd.output();\n      console.log(`📢 Notified system: ${event}`);\n      return true;\n    }\n    // Add other platforms as needed\n    return false;\n  } catch (error) {\n    console.error(`Failed to send ${event} notification:`, error.message);\n    return false;\n  }\n}\n\n// Export convenience functions for common events\nexport const notifyModuleSaved = (moduleName) => notifyEvent(\"module.saved\", { name: moduleName });\nexport const notifyModuleRemoved = (moduleName) => notifyEvent(\"module.removed\", { name: moduleName });\nexport const notifyDatabaseChanged = () => notifyEvent(\"database.changed\");",
  "core/platform.js": "// Platform module - Cross-platform OS information\n\nexport const os = Deno.build.os;\nexport const arch = Deno.build.arch;\nexport const version = Deno.osRelease();\nexport const isDarwin = os === \"darwin\";\nexport const isWindows = os === \"windows\";\nexport const isLinux = os === \"linux\";\nexport function tempDir() {\n  const envTemp = Deno.env.get(\"TMPDIR\") || \n                  Deno.env.get(\"TEMP\") || \n                  Deno.env.get(\"TMP\");\n  if (envTemp) return envTemp;\n  \n  if (isWindows) {\n    const userProfile = Deno.env.get(\"USERPROFILE\");\n    if (userProfile) {\n      return `${userProfile}\\\\AppData\\\\Local\\\\Temp`;\n    }\n    return \"C:\\\\Windows\\\\Temp\";\n  }\n  \n  return \"/tmp\";\n}\n\nexport function homeDir() {\n  if (isWindows) {\n    return Deno.env.get(\"USERPROFILE\") || Deno.env.get(\"HOMEDRIVE\") + Deno.env.get(\"HOMEPATH\");\n  }\n  return Deno.env.get(\"HOME\") || \"/\";\n}\n\n// Path and executable info\nexport const pathSep = isWindows ? \"\\\\\" : \"/\";\nexport const exeExt = isWindows ? \".exe\" : \"\";\n\n// Shell access\nexport function shell() {\n  if (isWindows) {\n    return [\"cmd\", \"/c\"];\n  }\n  return [\"sh\", \"-c\"];\n}\n\n// ===== MERGED FROM utils.js =====\n\n// Escape string for shell command (cross-platform)\nexport function escapeShell(str) {\n  if (isWindows) {\n    // PowerShell escaping\n    return str.replace(/\"/g, '`\"').replace(/\\$/g, '`$');\n  } else {\n    // Unix shell escaping\n    return str.replace(/'/g, \"'\\\\''\");\n  }\n}\n\n// Escape text for keyboard input (cross-platform)\nexport function escapeKeyboard(text) {\n  if (isWindows) {\n    // PowerShell SendKeys escaping\n    return text\n      .replace(/\\{/g, '{{')\n      .replace(/\\}/g, '}}')\n      .replace(/\\(/g, '{(}')\n      .replace(/\\)/g, '{)}')\n      .replace(/\\+/g, '{+}')\n      .replace(/\\^/g, '{^}')\n      .replace(/%/g, '{%}')\n      .replace(/~/g, '{~}');\n  } else {\n    // Unix shell escaping for osascript\n    return text.replace(/'/g, \"'\\\\''\");\n  }\n}\n\n// ===== MERGED FROM exec.js =====\n\n// Decode text from command output\nexport function decode(buffer) {\n  return new TextDecoder().decode(buffer);\n}\n\n// Run PowerShell command with standard args\nexport async function powershell(script) {\n  return await new Deno.Command(\"powershell\", {\n    args: [\"-NoProfile\", \"-Command\", script]\n  }).output();\n}\n\n// PowerShell script boilerplate\nexport const PS = {\n  forms: \"Add-Type -AssemblyName System.Windows.Forms\",\n  drawing: \"Add-Type -AssemblyName System.Drawing\",\n  visualBasic: \"Add-Type -AssemblyName Microsoft.VisualBasic\"\n};\n\n// Linux tool with xdotool/ydotool fallback\nexport async function linuxTool(xdotoolArgs, ydotoolArgs, errorMsg) {\n  try {\n    return await new Deno.Command(\"xdotool\", { args: xdotoolArgs }).output();\n  } catch {\n    try {\n      return await new Deno.Command(\"ydotool\", { args: ydotoolArgs }).output();\n    } catch {\n      throw new Error(errorMsg || \"Install xdotool (X11) or ydotool (Wayland)\");\n    }\n  }\n}\n\n// Common error messages\nexport const ERRORS = {\n  LINUX_TOOLS: \"Install xdotool (X11) or ydotool (Wayland)\",\n  LINUX_NOTIFY: \"Install libnotify-bin (notify-send)\",\n  LINUX_DIALOG: \"Install zenity or kdialog\"\n};",
  "core/repl.js": "// REPL module - REPL-specific functionality including history\n// History is saved to SQLite database for persistence across sessions\n\nimport { db, path as dbPath } from \"./database.js\";\n\n// Create history table if it doesn't exist\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS repl_history (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    command TEXT NOT NULL,\n    timestamp INTEGER NOT NULL\n  )\n`);\n\n// Create index for faster timestamp queries\ndb.exec(`\n  CREATE INDEX IF NOT EXISTS idx_repl_history_timestamp \n  ON repl_history(timestamp DESC)\n`);\n\n// History management\nexport const history = {\n  // Get history entries\n  get: (limit) => {\n    let query;\n    let params = [];\n    \n    if (typeof limit === 'number' && limit > 0) {\n      query = `\n        SELECT command, timestamp \n        FROM repl_history \n        ORDER BY timestamp DESC \n        LIMIT ?\n      `;\n      params = [limit];\n    } else {\n      query = `\n        SELECT command, timestamp \n        FROM repl_history \n        ORDER BY timestamp DESC\n      `;\n    }\n    \n    const rows = db.prepare(query).all(...params);\n    // Return in chronological order (oldest first)\n    return rows.reverse().map(r => r.command);\n  },\n  \n  // Search history for commands containing pattern\n  search: (pattern) => {\n    if (!pattern) return [];\n    \n    const rows = db.prepare(`\n      SELECT command, timestamp \n      FROM repl_history \n      WHERE command LIKE ? \n      ORDER BY timestamp DESC\n    `).all(`%${pattern}%`);\n    \n    return rows.map(r => r.command);\n  },\n  \n  // Clear all history\n  clear: () => {\n    db.exec(\"DELETE FROM repl_history\");\n    return true;\n  },\n  \n  // Get history count\n  size: () => {\n    const result = db.prepare(\"SELECT COUNT(*) as count FROM repl_history\").get();\n    return result.count;\n  },\n  \n  // Get last command\n  last: () => {\n    const row = db.prepare(`\n      SELECT command \n      FROM repl_history \n      ORDER BY timestamp DESC \n      LIMIT 1\n    `).get();\n    return row ? row.command : null;\n  },\n  \n  // Add command to history (internal use)\n  _add: (command) => {\n    if (!command || command.trim() === '') return false;\n    \n    // Don't add duplicate consecutive commands\n    const last = history.last();\n    if (last === command) return false;\n    \n    db.prepare(`\n      INSERT INTO repl_history (command, timestamp) \n      VALUES (?, ?)\n    `).run(command, Date.now());\n    \n    return true;\n  }\n};\n\n// Hook into global eval to capture all evaluations\n// This works for both REPL and GUI playground since both use eval\nif (globalThis.eval) {\n  const originalEval = globalThis.eval;\n  \n  // Replace global eval\n  globalThis.eval = function(code) {\n    // Save to history before eval (only if it's a string)\n    if (typeof code === 'string') {\n      history._add(code);\n    }\n    \n    // Call original eval\n    return originalEval.call(this, code);\n  };\n}\n\n// For GUI integration: The GUI sends commands through stdin which eventually\n// get evaluated. We can capture these by monitoring console outputs that indicate\n// a command was evaluated.\n\n// Check if we're in a context where we can access environment variables\nconst historyDb = Deno.env.get(\"HLVM_HISTORY_DB\");\n\n// Make the add function globally available for GUI/CLI integration\nif (typeof globalThis.__hlvm_history_buffer === 'undefined') {\n  globalThis.__hlvm_history_buffer = [];\n  globalThis.__hlvm_add_to_history = (cmd) => {\n    history._add(cmd);\n    globalThis.__hlvm_history_buffer.push(cmd);\n  };\n}\n\n// For CLI: The best we can do is provide a wrapper function\n// Users can use h() instead of direct eval to save history\nglobalThis.h = function(code) {\n  history._add(code);\n  return eval(code);\n};\n\n// Also provide a way to evaluate and save the last expression\nObject.defineProperty(globalThis, '_', {\n  get() {\n    // Get the last evaluated result (if available)\n    return globalThis.___lastResult;\n  },\n  set(value) {\n    globalThis.___lastResult = value;\n  }\n});\n\n// Export for use in hlvm namespace\nexport default {\n  history\n};",
  "core/system.js": "// System module - Cross-platform system utilities\n\nimport * as platform from \"./platform.js\";\n\nexport async function hostname() {\n  try {\n    return Deno.hostname();\n  } catch {\n    const p = new Deno.Command(\"hostname\");\n    const { stdout } = await p.output();\n    return new TextDecoder().decode(stdout).trim();\n  }\n}\n\nexport async function exec(cmd) {\n  const shell = platform.shell();\n  const p = new Deno.Command(shell[0], { \n    args: [...shell.slice(1), cmd] \n  });\n  const { stdout, stderr, code } = await p.output();\n  return {\n    stdout: new TextDecoder().decode(stdout),\n    stderr: new TextDecoder().decode(stderr),\n    code\n  };\n}\n\n// Direct exports from Deno\nexport const exit = Deno.exit;\nexport const pid = () => Deno.pid;\nexport const cwd = Deno.cwd;\nexport const chdir = Deno.chdir;\n\nexport function env(key, value) {\n  if (value !== undefined) {\n    Deno.env.set(key, value);\n  }\n  return Deno.env.get(key);\n}",
  "fs/filesystem.js": "// Filesystem module - Cross-platform file operations\n\nimport * as platform from \"../core/platform.js\";\n\nexport const read = (path) => Deno.readTextFile(path);\nexport const write = (path, content) => Deno.writeTextFile(path, content);\nexport const readBytes = (path) => Deno.readFile(path);\nexport const writeBytes = (path, data) => Deno.writeFile(path, data);\nexport async function exists(path) {\n  try {\n    await Deno.stat(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function remove(path, options = { recursive: true }) {\n  return Deno.remove(path, options);\n}\n\nexport function mkdir(path, options = { recursive: true }) {\n  return Deno.mkdir(path, options);\n}\n\nexport function readdir(path) {\n  return Deno.readDir(path);\n}\n\nexport async function stat(path) {\n  return Deno.stat(path);\n}\n\n// Cross-platform path utilities\nexport function join(...paths) {\n  return paths.join(platform.pathSep);\n}\n\nexport function dirname(path) {\n  const sep = platform.pathSep;\n  const lastIndex = path.lastIndexOf(sep);\n  return lastIndex === -1 ? \".\" : path.substring(0, lastIndex);\n}\n\nexport function basename(path, ext = \"\") {\n  const sep = platform.pathSep;\n  const lastIndex = path.lastIndexOf(sep);\n  const base = lastIndex === -1 ? path : path.substring(lastIndex + 1);\n  return ext && base.endsWith(ext) \n    ? base.substring(0, base.length - ext.length)\n    : base;\n}\n\nexport function extname(path) {\n  const lastDot = path.lastIndexOf(\".\");\n  return lastDot === -1 ? \"\" : path.substring(lastDot);\n}\n\n// Copy file or directory\nexport async function copy(src, dest) {\n  const srcStat = await stat(src);\n  \n  if (srcStat.isFile) {\n    const data = await readBytes(src);\n    await writeBytes(dest, data);\n  } else if (srcStat.isDirectory) {\n    await mkdir(dest);\n    for await (const entry of readdir(src)) {\n      await copy(\n        join(src, entry.name),\n        join(dest, entry.name)\n      );\n    }\n  }\n}\n\n// Move file or directory (cross-platform)\nexport async function move(src, dest) {\n  try {\n    await Deno.rename(src, dest);\n  } catch {\n    // If rename fails (e.g., across drives on Windows), copy and delete\n    await copy(src, dest);\n    await remove(src);\n  }\n}",
  "io/clipboard.js": "// Clipboard module - Cross-platform clipboard operations\n\nimport * as platform from \"../core/platform.js\";\n\nexport async function read() {\n  if (platform.isDarwin) {\n    // macOS: pbpaste (built-in)\n    const p = new Deno.Command(\"pbpaste\");\n    const { stdout } = await p.output();\n    return new TextDecoder().decode(stdout);\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell Get-Clipboard (built-in)\n    const p = new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", \"Get-Clipboard\"]\n    });\n    const { stdout } = await p.output();\n    return new TextDecoder().decode(stdout).replace(/\\r\\n$/, '');\n    \n  } else {\n    // Linux: Try multiple clipboard tools in order of preference\n    const tools = [\n      { cmd: \"xclip\", args: [\"-selection\", \"clipboard\", \"-o\"] },\n      { cmd: \"xsel\", args: [\"--clipboard\", \"--output\"] },\n      { cmd: \"wl-paste\", args: [] } // Wayland\n    ];\n    \n    for (const tool of tools) {\n      try {\n        const p = new Deno.Command(tool.cmd, { args: tool.args });\n        const { stdout, success } = await p.output();\n        if (success) {\n          return new TextDecoder().decode(stdout);\n        }\n      } catch {\n        // Try next tool\n      }\n    }\n    \n    throw new Error(\n      \"Clipboard read failed. Install one of: xclip, xsel, or wl-clipboard\"\n    );\n  }\n}\n\nexport async function write(text) {\n  if (platform.isDarwin) {\n    // macOS: pbcopy (built-in)\n    const p = new Deno.Command(\"pbcopy\", { stdin: \"piped\" });\n    const proc = p.spawn();\n    const writer = proc.stdin.getWriter();\n    await writer.write(new TextEncoder().encode(text));\n    await writer.close();\n    await proc.status;\n    \n  } else if (platform.isWindows) {\n    // Windows: PowerShell Set-Clipboard (built-in)\n    // Escape quotes for PowerShell\n    const escaped = text.replace(/\"/g, '`\"').replace(/\\$/g, '`$');\n    const p = new Deno.Command(\"powershell\", {\n      args: [\"-NoProfile\", \"-Command\", `Set-Clipboard -Value \"${escaped}\"`]\n    });\n    await p.output();\n    \n  } else {\n    // Linux: Try multiple clipboard tools\n    const tools = [\n      { cmd: \"xclip\", args: [\"-selection\", \"clipboard\"] },\n      { cmd: \"xsel\", args: [\"--clipboard\", \"--input\"] },\n      { cmd: \"wl-copy\", args: [] } // Wayland\n    ];\n    \n    for (const tool of tools) {\n      try {\n        const p = new Deno.Command(tool.cmd, { \n          args: tool.args,\n          stdin: \"piped\"\n        });\n        const proc = p.spawn();\n        const writer = proc.stdin.getWriter();\n        await writer.write(new TextEncoder().encode(text));\n        await writer.close();\n        const { success } = await proc.status;\n        if (success) return;\n      } catch {\n        // Try next tool\n      }\n    }\n    \n    throw new Error(\n      \"Clipboard write failed. Install one of: xclip, xsel, or wl-clipboard\"\n    );\n  }\n}\n\n// Check if clipboard is available\nexport async function isAvailable() {\n  try {\n    if (platform.isDarwin || platform.isWindows) {\n      return true; // Built-in support\n    }\n    \n    // Linux: Check for tools\n    const tools = [\"xclip\", \"xsel\", \"wl-paste\"];\n    for (const tool of tools) {\n      try {\n        const p = new Deno.Command(\"which\", { args: [tool] });\n        const { success } = await p.output();\n        if (success) return true;\n      } catch {}\n    }\n    return false;\n  } catch {\n    return false;\n  }\n}",
  "ui/control-safe.js": "// UI Control Module - Safe version for embedded environment\n// Returns stub if WebSocket not available\n\nlet ui;\n\n// Check if WebSocket is available\nif (typeof WebSocket !== 'undefined') {\n  // Full implementation\n  let socket = null;\n  let requestId = 0;\n  const pending = new Map();\n\n  async function connect(port = 11436) {\n    return new Promise((resolve, reject) => {\n      try {\n        socket = new WebSocket(`ws://localhost:${port}`);\n        \n        socket.onopen = () => {\n          console.log(\"Connected to macOS app\");\n          resolve(true);\n        };\n        \n        socket.onerror = (error) => {\n          reject(new Error(`Connection failed: ${error}`));\n        };\n        \n        socket.onmessage = (event) => {\n          try {\n            const msg = JSON.parse(event.data);\n            \n            if (msg.id && pending.has(msg.id)) {\n              const { resolve, reject } = pending.get(msg.id);\n              pending.delete(msg.id);\n              \n              if (msg.error) {\n                reject(new Error(msg.error.message));\n              } else {\n                resolve(msg.result);\n              }\n            }\n            \n            if (!msg.id && msg.method) {\n              handleNotification(msg.method, msg.params);\n            }\n          } catch (e) {\n            console.error(\"Message handling error:\", e);\n          }\n        };\n        \n        socket.onclose = () => {\n          console.log(\"Disconnected from macOS app\");\n          socket = null;\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  function handleNotification(method, params) {\n    console.log(`Notification: ${method}`, params);\n  }\n\n  async function request(method, params = {}) {\n    if (!socket || socket.readyState !== WebSocket.OPEN) {\n      throw new Error(\"Not connected to macOS app. Run hlvm.app.connect() first.\");\n    }\n    \n    const id = `${++requestId}`;\n    \n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        pending.delete(id);\n        reject(new Error(\"Request timeout\"));\n      }, 5000);\n      \n      pending.set(id, {\n        resolve: (result) => {\n          clearTimeout(timeout);\n          resolve(result);\n        },\n        reject: (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        }\n      });\n      \n      socket.send(JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params\n      }));\n    });\n  }\n\n  async function notify(method, params = {}) {\n    if (!socket || socket.readyState !== WebSocket.OPEN) {\n      console.warn(\"Not connected to macOS app\");\n      return;\n    }\n    \n    socket.send(JSON.stringify({\n      jsonrpc: \"2.0\",\n      method,\n      params\n    }));\n  }\n\n  ui = {\n    connect,\n    disconnect: () => {\n      if (socket) {\n        socket.close();\n        socket = null;\n      }\n    },\n    \n    isConnected: () => socket && socket.readyState === WebSocket.OPEN,\n    \n    spotlight: {\n      toggle: () => request(\"spotlight.toggle\"),\n      show: () => request(\"spotlight.show\"),\n      hide: () => request(\"spotlight.hide\"),\n      search: (query) => request(\"spotlight.search\", { query })\n    },\n    \n    chat: {\n      toggle: () => request(\"chat.toggle\"),\n      show: () => request(\"chat.show\"),\n      hide: () => request(\"chat.hide\"),\n      send: (message) => request(\"chat.send\", { message }),\n      clear: () => request(\"chat.clear\")\n    },\n    \n    preferences: () => request(\"app.preferences\"),\n    quit: () => request(\"app.quit\"),\n    \n    request,\n    notify\n  };\n} else {\n  // Stub implementation when WebSocket not available\n  const notAvailable = () => {\n    console.log(\"App control not available in this environment\");\n    return Promise.resolve(null);\n  };\n  \n  ui = {\n    connect: notAvailable,\n    disconnect: () => {},\n    isConnected: () => false,\n    \n    spotlight: {\n      toggle: notAvailable,\n      show: notAvailable,\n      hide: notAvailable,\n      search: notAvailable\n    },\n    \n    chat: {\n      toggle: notAvailable,\n      show: notAvailable,\n      hide: notAvailable,\n      send: notAvailable,\n      clear: notAvailable\n    },\n    \n    preferences: notAvailable,\n    quit: notAvailable,\n    \n    request: notAvailable,\n    notify: notAvailable\n  };\n}\n\nexport default ui;",
  "ui/control.js": "// UI Control Module - Control macOS GUI via WebSocket\n// Replaces __HLVM_COMMAND__ strings with proper JSON-RPC calls\n\nlet socket = null;\nlet requestId = 0;\nconst pending = new Map();\n\n// Connect to macOS app WebSocket server\nasync function connect(port = 11436) {\n  return new Promise((resolve, reject) => {\n    try {\n      socket = new WebSocket(`ws://localhost:${port}`);\n      \n      socket.onopen = () => {\n        console.log(\"Connected to macOS app\");\n        resolve(true);\n      };\n      \n      socket.onerror = (error) => {\n        reject(new Error(`Connection failed: ${error}`));\n      };\n      \n      socket.onmessage = (event) => {\n        try {\n          const msg = JSON.parse(event.data);\n          \n          // Handle response to our request\n          if (msg.id && pending.has(msg.id)) {\n            const { resolve, reject } = pending.get(msg.id);\n            pending.delete(msg.id);\n            \n            if (msg.error) {\n              reject(new Error(msg.error.message));\n            } else {\n              resolve(msg.result);\n            }\n          }\n          \n          // Handle notifications from app\n          if (!msg.id && msg.method) {\n            handleNotification(msg.method, msg.params);\n          }\n        } catch (e) {\n          console.error(\"Message handling error:\", e);\n        }\n      };\n      \n      socket.onclose = () => {\n        console.log(\"Disconnected from macOS app\");\n        socket = null;\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n// Send JSON-RPC request and wait for response\nasync function request(method, params = null) {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    // Try to connect\n    try {\n      await connect();\n    } catch {\n      return { error: \"macOS app not available\" };\n    }\n  }\n  \n  const id = `req-${++requestId}`;\n  \n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      pending.delete(id);\n      reject(new Error(\"Request timeout\"));\n    }, 5000);\n    \n    pending.set(id, { \n      resolve: (result) => {\n        clearTimeout(timeout);\n        resolve(result);\n      }, \n      reject: (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n    \n    const request = {\n      jsonrpc: \"2.0\",\n      id,\n      method,\n      params\n    };\n    \n    socket.send(JSON.stringify(request));\n  });\n}\n\n// Send notification (no response expected)\nfunction notify(method, params = null) {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn(\"App not connected\");\n    return;\n  }\n  \n  const notification = {\n    jsonrpc: \"2.0\",\n    method,\n    params\n  };\n  \n  socket.send(JSON.stringify(notification));\n}\n\n// Handle notifications from app\nfunction handleNotification(method, params) {\n  console.log(`Notification from app: ${method}`, params);\n  \n  // Emit events if needed\n  if (globalThis.hlvm?.events) {\n    globalThis.hlvm.events.emit(method, params);\n  }\n}\n\n// UI control commands (replacing __HLVM_COMMAND__ strings)\nexport const ui = {\n  // Connection management\n  connect,\n  disconnect: () => {\n    if (socket) {\n      socket.close();\n      socket = null;\n    }\n  },\n  \n  isConnected: () => socket && socket.readyState === WebSocket.OPEN,\n  \n  // Spotlight commands (replacing __HLVM_SPOTLIGHT_*)\n  spotlight: {\n    toggle: () => request(\"spotlight.toggle\"),\n    show: () => request(\"spotlight.show\"),\n    hide: () => request(\"spotlight.hide\"),\n    navigateIn: () => request(\"spotlight.navigateIn\"),\n    navigateOut: () => request(\"spotlight.navigateOut\"),\n    search: (query) => request(\"spotlight.search\", { query }),\n    \n    // Note: Module management moved to hlvm.modules for generic use\n  },\n  \n  // Chat commands (replacing __HLVM_CHAT_*)\n  chat: {\n    toggle: () => request(\"chat.toggle\"),\n    stop: () => request(\"chat.stop\"),\n    cancel: () => request(\"chat.cancel\"),\n    createRoom: (name) => request(\"chat.createRoom\", { name }),\n    send: (message) => request(\"chat.send\", { message }),\n    list: () => request(\"chat.list\"),\n    selectRoom: (id) => request(\"chat.selectRoom\", { id }),\n    ask: (prompt) => request(\"chat.ask\", { prompt })\n  },\n  \n  // Playground commands (replacing __HLVM_PLAYGROUND_*)\n  playground: {\n    toggle: () => request(\"playground.toggle\"),\n    eval: (code) => request(\"playground.eval\", { code }),\n    increaseFont: () => request(\"playground.increaseFont\"),\n    decreaseFont: () => request(\"playground.decreaseFont\"),\n    setCode: (code) => request(\"playground.setCode\", { code })\n  },\n  \n  // Screenshot commands (replacing __HLVM_SCREENSHOT_*)\n  screenshot: {\n    capture: () => request(\"screenshot.capture\"),\n    captureScreen: () => request(\"screenshot.captureScreen\"),\n    captureEntire: () => request(\"screenshot.captureEntire\"),\n    captureSelection: () => request(\"screenshot.captureSelection\")\n  },\n  \n  // App commands (replacing __HLVM_APP_*)\n  preferences: () => request(\"app.preferences\"),\n  escape: () => request(\"app.escape\"),\n  eval: (code) => request(\"app.eval\", { code }),\n  settings: () => request(\"app.settings\"),\n  textEditor: () => request(\"app.textEditor\"),\n  minimize: () => request(\"app.minimize\"),\n  quit: () => request(\"app.quit\"),\n  \n  // Code commands (replacing __HLVM_CODE_*)\n  code: {\n    paste: (code) => request(\"code.paste\", { code }),\n    copy: () => request(\"code.copy\")\n  },\n  \n  // Utility commands\n  // Note: Clipboard operations use hlvm.clipboard directly (not via WebSocket)\n  \n  // REPL commands\n  repl: {\n    toggle: () => request(\"repl.toggle\"),\n    clear: () => request(\"repl.clear\"),\n    execute: (code) => request(\"repl.execute\", { code })\n  },\n  \n  // AI commands\n  ai: {\n    write: (prompt) => request(\"ai.write\", { prompt })\n  },\n  \n  // Raw request for custom commands\n  request,\n  notify\n};\n\nexport default ui;"
};

export const embeddedInit = "// HLVM Initialization - Clean Mediator\n// Imports all stdlib modules and exposes them through the hlvm namespace\n\n// Import all stdlib modules from organized structure\nimport * as platform from \"./stdlib/core/platform.js\";\nimport * as system from \"./stdlib/core/system.js\";\nimport * as db from \"./stdlib/core/database.js\";\nimport repl from \"./stdlib/core/repl.js\";\nimport * as fs from \"./stdlib/fs/filesystem.js\";\nimport * as clipboard from \"./stdlib/io/clipboard.js\";\nimport * as notification from \"./stdlib/computer/notification.js\";\nimport * as screen from \"./stdlib/computer/screen.js\";\nimport * as keyboard from \"./stdlib/computer/keyboard.js\";\nimport * as mouse from \"./stdlib/computer/mouse.js\";\nimport * as ollama from \"./stdlib/ai/ollama.js\";\nimport ui from \"./stdlib/ui/control.js\";\nimport { context as computerContext } from \"./stdlib/computer/context.js\";\n\n// Create hlvm namespace\nconst hlvmBase = {\n  // Module management - generic for all UIs\n  modules: {\n    save: db.save,\n    remove: async (name) => {\n      // If no name given, remove ALL modules (nuke)\n      if (!name) {\n        const allModules = db.list();\n        for (const mod of allModules) {\n          await db.remove(mod.key);\n        }\n        console.log(`Removed all ${allModules.length} modules`);\n        return true;\n      }\n      // Otherwise remove specific module\n      return db.remove(name);\n    },\n    list: db.list,\n    load: db.load,\n    get: db.getSource,\n    has: async (name) => {\n      const modules = db.list();\n      return modules.some(m => m.key === name);\n    },\n    \n    // Shortcut management - permanent global shortcuts\n    shortcut: async (name, path) => {\n      // Remove shortcut if path is null\n      if (path === null || path === undefined) {\n        return removeShortcut(name);\n      }\n      return createShortcut(name, path);\n    },\n    shortcuts: () => listShortcuts(),\n    removeShortcut: (name) => removeShortcut(name),\n    updateShortcut: (name, path) => createShortcut(name, path)\n  },\n  \n  // Database access (for advanced users)\n  db: Object.assign(db.db, {\n    path: db.path,\n    load: db.load,\n    getSource: db.getSource\n  }),\n  \n  // System modules\n  platform,\n  system,\n  fs,\n  repl: repl.history,\n  clipboard,\n  \n  // Computer control - grouped for context access\n  computer: {\n    notification,\n    screen,\n    keyboard,\n    mouse,\n    clipboard,\n    context: computerContext\n  },\n  \n  // UI namespace\n  ui: {\n    notification\n  },\n  \n  // AI namespace\n  ai: {\n    ollama\n  },\n  \n  // App control (GUI when available)\n  app: ui,\n  \n  // Context - returns context object\n  get context() {\n    return computerContext;\n  },\n  \n  // Help\n  help: () => {\n    console.log(`\nHLVM - High-Level Virtual Machine\n==================================\n\nCore Functions:\n  hlvm.modules.save()       - Save module\n  hlvm.modules.remove()     - Remove module(s)\n  hlvm.modules.list()       - List modules\n  hlvm.modules.load()       - Load module\n  hlvm.modules.shortcut()   - Create global shortcut\n  hlvm.modules.shortcuts()  - List all shortcuts\n  hlvm.context              - System context (selection, screen)\n\nSystem Control:\n  hlvm.platform             - Platform info (os, arch, etc)\n  hlvm.system               - System utilities\n  hlvm.fs                   - File system operations\n\nComputer Control:\n  hlvm.computer.notification - UI dialogs (alert, notify, confirm, prompt)\n  hlvm.computer.screen      - Screen capture\n  hlvm.computer.keyboard    - Keyboard automation (type, press)\n  hlvm.computer.mouse       - Mouse automation (move, click, position)\n  hlvm.computer.clipboard   - Clipboard operations\n\nAI Services:\n  hlvm.ai.ollama.list()     - List available models\n  hlvm.ai.ollama.chat()     - Chat with AI model\n\nFile Operations:\n  hlvm.fs.read(path)        - Read text file\n  hlvm.fs.write(path, text) - Write text file\n  hlvm.fs.readBytes(path)   - Read binary file\n  hlvm.fs.writeBytes(path)  - Write binary file\n  hlvm.fs.exists(path)      - Check if path exists\n  hlvm.fs.remove(path)      - Delete file/directory\n  hlvm.fs.mkdir(path)       - Create directory\n  hlvm.fs.copy(src, dest)   - Copy file/directory\n  hlvm.fs.move(src, dest)   - Move file/directory\n\nExamples:\n  // Files\n  await hlvm.fs.write('/tmp/test.txt', 'Hello')\n  const text = await hlvm.fs.read('/tmp/test.txt')\n  \n  // Notifications\n  await hlvm.computer.notification.notify(\"Done!\", \"HLVM\")\n  const name = await hlvm.computer.notification.prompt(\"Name?\")\n  \n  // Automation\n  await hlvm.computer.screen.capture(\"/tmp/screen.png\")\n  await hlvm.computer.keyboard.type(\"Hello\")\n  await hlvm.computer.mouse.click(100, 100)\n    `);\n  },\n  \n  // Status\n  status: () => {\n    const modules = Object.keys(hlvm).filter(k => typeof hlvm[k] === 'object');\n    const savedModules = hlvm.modules.list();\n    \n    console.log('\\nHLVM Status:');\n    console.log('─'.repeat(40));\n    console.log('System Modules:', modules.join(', '));\n    console.log(`Saved Modules: ${savedModules.length} modules`);\n    console.log(`Database: ${db.path}`);\n    console.log(`Platform: ${platform.os} (${platform.arch})`);\n    console.log(`Temp Dir: ${platform.tempDir()}`);\n    console.log(`Home Dir: ${platform.homeDir()}`);\n  }\n};\n\n// Setup shortcut persistence\nfunction setupShortcuts() {\n  // Create shortcuts table if not exists\n  db.db.exec(`\n    CREATE TABLE IF NOT EXISTS shortcuts (\n      name TEXT PRIMARY KEY,\n      path TEXT NOT NULL,\n      created_at INTEGER NOT NULL,\n      updated_at INTEGER NOT NULL\n    )\n  `);\n  \n  // Load existing shortcuts and create global functions\n  const shortcuts = db.db.prepare('SELECT * FROM shortcuts').all();\n  shortcuts.forEach(shortcut => {\n    try {\n      // Create the global shortcut function\n      globalThis[shortcut.name] = async (...args) => {\n        // Navigate the path to find the function\n        const parts = shortcut.path.split('.');\n        let current = globalThis;\n        for (const part of parts) {\n          current = current[part];\n          if (!current) {\n            throw new Error(`Path ${shortcut.path} not found`);\n          }\n        }\n        \n        // Call the function if it's callable\n        if (typeof current === 'function') {\n          return await current(...args);\n        }\n        return current;\n      };\n    } catch (e) {\n      console.error(`Failed to restore shortcut '${shortcut.name}':`, e.message);\n    }\n  });\n}\n\n// Create a shortcut\nfunction createShortcut(name, path) {\n  // Validate name doesn't conflict with system\n  const reserved = ['hlvm', 'Deno', 'console', 'global', 'globalThis', 'window', \n                    'document', 'alert', 'confirm', 'prompt', 'eval', 'Function',\n                    'Object', 'Array', 'String', 'Number', 'Boolean', 'Symbol',\n                    'Math', 'Date', 'RegExp', 'Error', 'JSON', 'Promise'];\n  \n  if (reserved.includes(name)) {\n    throw new Error(`Cannot use reserved name '${name}' for shortcut`);\n  }\n  \n  // Save to database\n  const now = Date.now();\n  db.db.prepare(`\n    INSERT OR REPLACE INTO shortcuts (name, path, created_at, updated_at)\n    VALUES (?, ?, ?, ?)\n  `).run(name, path, now, now);\n  \n  // Create the global function\n  globalThis[name] = async (...args) => {\n    const parts = path.split('.');\n    let current = globalThis;\n    for (const part of parts) {\n      current = current[part];\n      if (!current) {\n        throw new Error(`Path ${path} not found`);\n      }\n    }\n    \n    if (typeof current === 'function') {\n      return await current(...args);\n    }\n    return current;\n  };\n  \n  console.log(`✅ Created shortcut: ${name}() → ${path}`);\n  return true;\n}\n\n// Remove a shortcut\nfunction removeShortcut(name) {\n  // Remove from database\n  db.db.prepare('DELETE FROM shortcuts WHERE name = ?').run(name);\n  \n  // Remove from global scope\n  delete globalThis[name];\n  \n  console.log(`✅ Removed shortcut: ${name}`);\n  return true;\n}\n\n// List all shortcuts\nfunction listShortcuts() {\n  const shortcuts = db.db.prepare('SELECT * FROM shortcuts ORDER BY name').all();\n  return shortcuts.map(s => ({\n    name: s.name,\n    path: s.path,\n    createdAt: new Date(s.created_at),\n    updatedAt: new Date(s.updated_at)\n  }));\n}\n\n// Setup custom property persistence\nfunction setupCustomPropertyPersistence() {\n  // Create custom_properties table if not exists\n  db.db.exec(`\n    CREATE TABLE IF NOT EXISTS custom_properties (\n      key TEXT PRIMARY KEY,\n      value TEXT NOT NULL,\n      type TEXT NOT NULL,\n      updated_at INTEGER NOT NULL\n    )\n  `);\n  \n  // Load existing custom properties\n  const props = db.db.prepare('SELECT * FROM custom_properties').all();\n  props.forEach(prop => {\n    try {\n      if (prop.type === 'function') {\n        // Recreate function from string\n        hlvmBase[prop.key] = eval(`(${prop.value})`);\n      } else {\n        hlvmBase[prop.key] = JSON.parse(prop.value);\n      }\n    } catch (e) {\n      console.error(`Failed to restore custom property '${prop.key}':`, e.message);\n    }\n  });\n}\n\n// Save custom property to database\nfunction saveCustomProperty(key, value) {\n  let serialized;\n  let type = typeof value;\n  \n  if (value === null || value === undefined) {\n    // Handle null/undefined - remove from database\n    db.db.prepare('DELETE FROM custom_properties WHERE key = ?').run(key);\n    return;\n  }\n  \n  if (type === 'function') {\n    serialized = value.toString();\n  } else {\n    serialized = JSON.stringify(value);\n  }\n  \n  db.db.prepare(`\n    INSERT OR REPLACE INTO custom_properties (key, value, type, updated_at)\n    VALUES (?, ?, ?, ?)\n  `).run(key, serialized, type, Date.now());\n}\n\n// Setup persistence\nsetupShortcuts();\nsetupCustomPropertyPersistence();\n\n// Create proxy for custom properties\nglobalThis.hlvm = new Proxy(hlvmBase, {\n  set(target, prop, value) {\n    // List of system properties that cannot be overridden\n    const systemProps = ['modules', 'db', 'platform', 'system', 'fs', 'clipboard', 'notification', \n                        'screen', 'keyboard', 'mouse', 'ui', 'ai', 'app', 'computer', 'context', \n                        'help', 'status', 'repl'];\n    \n    if (systemProps.includes(prop)) {\n      console.error(`Cannot override system property: hlvm.${prop}`);\n      return false;\n    }\n    \n    // Save to database for persistence\n    saveCustomProperty(prop, value);\n    \n    // Set the value\n    if (value === null || value === undefined) {\n      delete target[prop];\n    } else {\n      target[prop] = value;\n    }\n    return true;\n  },\n  \n  deleteProperty(target, prop) {\n    // Remove from database\n    db.db.prepare('DELETE FROM custom_properties WHERE key = ?').run(prop);\n    delete target[prop];\n    return true;\n  }\n});\n\n// Global utilities\nglobalThis.pprint = (obj) => console.log(JSON.stringify(obj, null, 2));\n\n// Global shorthand for context\nObject.defineProperty(globalThis, 'context', {\n  get() { return hlvm.context; },\n  enumerable: true,\n  configurable: false\n});";
export const embeddedBridge = "// HLVM Bridge - WebSocket server for GUI control commands\n// NOTE: JavaScript eval uses stdin/stdout, NOT this WebSocket bridge\n// This bridge is only for hlvm.app GUI control commands\n\ninterface JSONRPCRequest {\n  jsonrpc: \"2.0\";\n  id?: string | number;\n  method: string;\n  params?: any;\n}\n\ninterface JSONRPCResponse {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}\n\ninterface JSONRPCNotification {\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: any;\n}\n\nclass HLVMBridge {\n  private connections = new Set<WebSocket>();\n  private server?: Deno.HttpServer;\n  private handlers = new Map<string, (params: any) => Promise<any>>();\n\n  constructor() {\n    this.registerHandlers();\n  }\n\n  private registerHandlers() {\n    // GUI Control handlers (eval is handled via stdin/stdout, not WebSocket)\n\n    this.handlers.set(\"system.info\", async () => {\n      return {\n        platform: Deno.build.os,\n        arch: Deno.build.arch,\n        version: \"2.0\",\n        pid: Deno.pid\n      };\n    });\n\n    // Module handlers (keep existing functionality)\n    this.handlers.set(\"modules.list\", async () => {\n      // Call existing hlvm.modules.list() function\n      if (globalThis.hlvm?.modules?.list) {\n        return globalThis.hlvm.modules.list();\n      }\n      return [];\n    });\n\n    this.handlers.set(\"modules.save\", async (params) => {\n      if (globalThis.hlvm?.modules?.save) {\n        return await globalThis.hlvm.modules.save(params.name, params.code);\n      }\n      throw new Error(\"Module save not available\");\n    });\n\n    this.handlers.set(\"modules.load\", async (params) => {\n      if (globalThis.hlvm?.modules?.load) {\n        return await globalThis.hlvm.modules.load(params.name);\n      }\n      throw new Error(\"Module load not available\");\n    });\n\n    // AI handlers\n    this.handlers.set(\"ai.generate\", async (params) => {\n      if (globalThis.hlvm?.ai?.ollama?.chat) {\n        return await globalThis.hlvm.ai.ollama.chat(params.prompt, params.model);\n      }\n      throw new Error(\"AI not available\");\n    });\n\n    // File system handlers\n    this.handlers.set(\"fs.read\", async (params) => {\n      return await Deno.readTextFile(params.path);\n    });\n\n    this.handlers.set(\"fs.write\", async (params) => {\n      await Deno.writeTextFile(params.path, params.content);\n      return { success: true };\n    });\n\n    this.handlers.set(\"fs.exists\", async (params) => {\n      try {\n        await Deno.stat(params.path);\n        return true;\n      } catch {\n        return false;\n      }\n    });\n  }\n\n  async start(port = 11436) {\n    // Start server without blocking\n    this.server = Deno.serve({ port, onListen: () => {\n      console.log(`HLVM Bridge running on ws://localhost:${port}`);\n    }}, (req) => {\n      // Handle WebSocket upgrade\n      if (req.headers.get(\"upgrade\") === \"websocket\") {\n        const { socket, response } = Deno.upgradeWebSocket(req);\n        \n        socket.onopen = () => {\n          console.log(\"macOS app connected\");\n          this.connections.add(socket);\n          \n          // Send connection confirmation\n          const notification: JSONRPCNotification = {\n            jsonrpc: \"2.0\",\n            method: \"connection.established\",\n            params: {\n              version: \"2.0\",\n              capabilities: Array.from(this.handlers.keys())\n            }\n          };\n          socket.send(JSON.stringify(notification));\n        };\n\n        socket.onmessage = async (event) => {\n          try {\n            const request = JSON.parse(event.data) as JSONRPCRequest;\n            \n            if (request.jsonrpc !== \"2.0\") {\n              throw new Error(\"Invalid JSON-RPC version\");\n            }\n\n            // Handle request with response\n            if (request.id !== undefined) {\n              const response: JSONRPCResponse = {\n                jsonrpc: \"2.0\",\n                id: request.id\n              };\n\n              try {\n                const handler = this.handlers.get(request.method);\n                if (!handler) {\n                  response.error = {\n                    code: -32601,\n                    message: `Method not found: ${request.method}`\n                  };\n                } else {\n                  response.result = await handler(request.params);\n                }\n              } catch (error) {\n                response.error = {\n                  code: -32603,\n                  message: error.message\n                };\n              }\n\n              socket.send(JSON.stringify(response));\n            } \n            // Handle notification (no response)\n            else {\n              const handler = this.handlers.get(request.method);\n              if (handler) {\n                handler(request.params).catch(console.error);\n              }\n            }\n          } catch (error) {\n            console.error(\"Message handling error:\", error);\n          }\n        };\n\n        socket.onclose = () => {\n          console.log(\"macOS app disconnected\");\n          this.connections.delete(socket);\n        };\n\n        socket.onerror = (error) => {\n          console.error(\"WebSocket error:\", error);\n        };\n\n        return response;\n      }\n\n      // Regular HTTP endpoint for health check\n      if (req.url.endsWith(\"/health\")) {\n        return new Response(JSON.stringify({ status: \"ok\", connections: this.connections.size }), {\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n      }\n\n      return new Response(\"HLVM Bridge WebSocket Server\", { status: 200 });\n    });\n  }\n\n  // Send notification to all connected clients\n  broadcast(method: string, params?: any) {\n    const notification: JSONRPCNotification = {\n      jsonrpc: \"2.0\",\n      method,\n      params\n    };\n    \n    const message = JSON.stringify(notification);\n    for (const socket of this.connections) {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(message);\n      }\n    }\n  }\n\n  // Send request to macOS app and wait for response\n  async request(method: string, params?: any): Promise<any> {\n    if (this.connections.size === 0) {\n      throw new Error(\"No macOS app connected\");\n    }\n\n    const socket = this.connections.values().next().value;\n    const id = `req-${Date.now()}-${Math.random()}`;\n    \n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(\"Request timeout\"));\n      }, 5000);\n\n      const handler = (event: MessageEvent) => {\n        try {\n          const response = JSON.parse(event.data) as JSONRPCResponse;\n          if (response.id === id) {\n            clearTimeout(timeout);\n            socket.removeEventListener(\"message\", handler);\n            \n            if (response.error) {\n              reject(new Error(response.error.message));\n            } else {\n              resolve(response.result);\n            }\n          }\n        } catch {}\n      };\n\n      socket.addEventListener(\"message\", handler);\n      \n      const request: JSONRPCRequest = {\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params\n      };\n      \n      socket.send(JSON.stringify(request));\n    });\n  }\n\n  stop() {\n    for (const socket of this.connections) {\n      socket.close();\n    }\n    this.connections.clear();\n    this.server?.shutdown();\n  }\n}\n\n// Export for use in HLVM\nexport { HLVMBridge };\nexport const bridge = new HLVMBridge();\n\n// Start bridge if running as standalone\nif (import.meta.main) {\n  await bridge.start(11436);\n}";
